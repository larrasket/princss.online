<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Effective Go: A Conclusion</title>
<meta name="author" content="Salih Muhammed" />
<meta name="generator" content="Org Mode" />
<!doctype html>
<html>
  <head>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Amiri:ital,wght@0,400;0,700;1,400;1,700&family=Arimo:ital,wght@0,400..700;1,400..700&display=swap"
      rel="stylesheet"
    />
    <meta name="theme-color" content="#ffffff" />
    <meta charset="utf-8" />
    <meta name="theme-color" content="#ffffff" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="/~saleh/style/toc.css?v=20250130" />
    <link rel="stylesheet" href="/~saleh/style/tufte.css?v=20250130" />
    <link rel="stylesheet" href="/~saleh/style/main.css?v=20250230" />

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const p = document.querySelector("#content > p:first-of-type");
        if (p && /^[\u0600-\u06FF]/.test(p.textContent.trim())) {
          p.classList.add("arabic");
        }
      });
    </script>

    <script async data-id="101390423" src="//static.getclicky.com/js"></script>
    <noscript>
      <p>
        <img
          alt="Clicky"
          width="1"
          height="1"
          src="//in.getclicky.com/101390423ns.gif"
        /></p
    ></noscript>

    <!-- Import LazySizes - State-of-the-art lazy loading library -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/lazysizes.min.js"
      async
    ></script>

    <!-- Optional: Import plugins for better performance -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/plugins/unveilhooks/ls.unveilhooks.min.js"
      async
    ></script>

    <script>
      // Only run on pages with 'art_paintings_media' in the path
      if (window.location.pathname.includes("art_paintings_media")) {
        document.addEventListener("DOMContentLoaded", function () {
          // Configure LazySizes for optimal performance
          window.lazySizesConfig = window.lazySizesConfig || {};
          window.lazySizesConfig.loadMode = 1; // Load images one at a time for better performance
          window.lazySizesConfig.expand = 50; // Load images 50px before they enter viewport
          window.lazySizesConfig.expFactor = 1.5; // Expand loading area
          window.lazySizesConfig.hFac = 0.4; // Height factor for loading trigger

          // Add CSS for smooth transitions and collapsible content
          const style = document.createElement("style");
          style.textContent = `
      .lazyload,
      .lazyloading {
        opacity: 0;
        transition: opacity 0.4s ease-in-out;
      }
      .lazyloaded {
        opacity: 1;
      }
      .collapsible-content {
        overflow: hidden;
        transition: max-height 0.3s ease-out;
      }
      .collapsible-content.collapsed {
        max-height: 0 !important;
      }
      .collapsible-content.expanded {
        max-height: none;
      }
      /* Blur effect while loading (optional) */
      .lazyloading {
        filter: blur(5px);
        opacity: 0.7;
      }
      .lazyloaded {
        filter: none;
      }
    `;
          document.head.appendChild(style);

          // Find all h3 elements
          const h3Elements = document.querySelectorAll("h3");

          h3Elements.forEach(function (h3) {
            // Make h3 clickable and add icon
            h3.style.position = "relative";
            h3.style.cursor = "pointer";
            h3.style.paddingLeft = "20px";
            h3.style.userSelect = "none";

            // Add the arrow icon
            const icon = document.createElement("span");
            icon.innerHTML = "▶";
            icon.style.position = "absolute";
            icon.style.left = "0px";
            icon.style.top = "50%";
            icon.style.transform = "translateY(-50%)";
            icon.style.transition = "transform 0.2s";
            icon.style.fontSize = "0.8em";
            icon.style.color = "rgb(102, 102, 102)";
            icon.style.fontFamily = "monospace";

            h3.insertBefore(icon, h3.firstChild);

            // Find all content after this h3 until the next h3 or end of parent
            const contentElements = [];
            let nextElement = h3.nextElementSibling;

            while (nextElement && nextElement.tagName !== "H3") {
              contentElements.push(nextElement);
              nextElement = nextElement.nextElementSibling;
            }

            // Create a wrapper for smooth collapsing
            const wrapper = document.createElement("div");
            wrapper.className = "collapsible-content collapsed";
            wrapper.style.maxHeight = "0";

            // Move content elements into wrapper
            contentElements.forEach(function (element) {
              wrapper.appendChild(element);
            });

            // Insert wrapper after h3
            h3.parentNode.insertBefore(wrapper, h3.nextSibling);

            // Prepare images for LazySizes lazy loading and make them clickable
            const prepareImagesForLazyLoading = (container) => {
              const images = container.querySelectorAll("img");
              images.forEach(function (img) {
                // Only process if not already processed
                if (
                  !img.classList.contains("lazyload") &&
                  !img.dataset.processed
                ) {
                  // Store original src in data-src for LazySizes
                  if (
                    img.src &&
                    img.src !== "" &&
                    !img.src.startsWith("data:")
                  ) {
                    img.dataset.src = img.src;
                    // Use a tiny placeholder or low-quality placeholder
                    img.src =
                      'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1 1"%3E%3Crect width="1" height="1" fill="%23f0f0f0"/%3E%3C/svg%3E';
                  }

                  // Handle srcset for responsive images
                  if (img.srcset && img.srcset !== "") {
                    img.dataset.srcset = img.srcset;
                    img.srcset = "";
                  }

                  // Handle sizes attribute
                  if (img.sizes) {
                    img.dataset.sizes = img.sizes;
                  }

                  // Add LazySizes classes
                  img.classList.add("lazyload");

                  // Make image clickable - add cursor pointer
                  img.style.cursor = "pointer";

                  // Add click handler to open image in new tab
                  img.addEventListener("click", function (e) {
                    e.preventDefault();
                    e.stopPropagation(); // Prevent triggering h3 collapse

                    // Get the actual image URL (either from src or data-src)
                    let imageUrl = this.src;
                    if (this.dataset.src && !this.src.startsWith("data:")) {
                      imageUrl = this.dataset.src;
                    } else if (
                      this.src.startsWith("data:") &&
                      this.dataset.src
                    ) {
                      imageUrl = this.dataset.src;
                    }

                    // Open image in new tab
                    if (imageUrl && !imageUrl.startsWith("data:")) {
                      window.open(imageUrl, "_blank");
                    }
                  });

                  // Mark as processed
                  img.dataset.processed = "true";

                  // Maintain aspect ratio to prevent layout shift
                  if (!img.style.aspectRatio && img.width && img.height) {
                    img.style.aspectRatio = img.width + "/" + img.height;
                  }
                }
              });
            };

            // Prepare all images in this section for lazy loading
            prepareImagesForLazyLoading(wrapper);

            // Track collapsed state
            let isCollapsed = true;
            let hasBeenExpanded = false;

            // Add click handler
            h3.addEventListener("click", function (e) {
              e.preventDefault();

              if (isCollapsed) {
                // Expand: show content and activate lazy loading
                icon.style.transform = "translateY(-50%) rotate(90deg)";
                wrapper.classList.remove("collapsed");
                wrapper.classList.add("expanded");
                wrapper.style.maxHeight = wrapper.scrollHeight + "px";

                // Only activate LazySizes for this section when first expanded
                if (!hasBeenExpanded) {
                  // Trigger LazySizes to check for images in this newly visible section
                  if (window.lazySizes) {
                    // Force LazySizes to check all images in this wrapper
                    const lazyImages = wrapper.querySelectorAll(".lazyload");
                    lazyImages.forEach((img) => {
                      // Add to LazySizes queue
                      window.lazySizes.loader.unveil(img);
                    });
                  }
                  hasBeenExpanded = true;
                }

                isCollapsed = false;

                // Recalculate height after images potentially load
                setTimeout(() => {
                  if (!isCollapsed) {
                    wrapper.style.maxHeight = wrapper.scrollHeight + "px";
                  }
                }, 100);
              } else {
                // Collapse: hide content
                icon.style.transform = "translateY(-50%) rotate(0deg)";
                wrapper.classList.remove("expanded");
                wrapper.classList.add("collapsed");
                wrapper.style.maxHeight = "0";

                isCollapsed = true;
              }
            });

            // Listen for LazySizes events to adjust height dynamically
            wrapper.addEventListener("lazyloaded", function (e) {
              if (!isCollapsed) {
                // Adjust wrapper height when images load
                setTimeout(() => {
                  wrapper.style.maxHeight = wrapper.scrollHeight + "px";
                }, 50);
              }
            });
          });
        });
      }
    </script>

    <script>
      (function () {
        "use strict";

        // Check if current page should have the formatting applied
        function shouldApplyFormatting() {
          const path = window.location.pathname;

          // Check if path matches our target patterns
          return (
            path === "/stack" ||
            path === "/stack.html" ||
            path.startsWith("/sh/")
          );
        }

        // Only proceed if we're on a target page
        if (!shouldApplyFormatting()) {
          return;
        }

        // Add CSS styles
        function addStyles() {
          const style = document.createElement("style");
          style.textContent = `
      /* Basic styling for entries */
      .outline-3 {
        margin-bottom: 1.5em;
        line-height: 1.5;
      }

      /* Style for reconstructed single paragraph */
      .entry-paragraph {
        margin: 0;
        line-height: 1.5;
        direction: inherit;
        unicode-bidi: plaintext;
      }

      /* Style for date - gray and nice */
      .entry-date {
        color: #666;
        font-size: 0.9em;
        margin-right: 0.5em;
      }

      /* Style for tag at end - gray and in parentheses */
      .entry-tag {
        display: inline !important;
        color: #666;
        margin-left: 0.5em;
      }

      /* Ensure all children stay inline */
      .entry-tag * {
        display: inline !important;
      }

      /* Override any existing tag styles */
      .entry-tag p,
      .entry-tag div {
        display: inline !important;
        margin: 0 !important;
        padding: 0 !important;
      }


      /* Hide block elements that will be moved */
      .outline-3 .moved-block {
        display: block;
        margin: 0.5em 0;
      }

      /* Ensure proper anchor target visibility */
      .outline-3[id] {
        scroll-margin-top: 20px;
      }
    `;
          document.head.appendChild(style);
        }

        // Extract ID from container div
        function extractIdFromContainer(entry) {
          const containerId = entry.id;
          if (containerId && containerId.startsWith("outline-container-")) {
            return containerId.replace("outline-container-", "");
          }
          return null;
        }

        // Apply the formatting transformation
        function applyFormatting() {
          // Process each entry
          const entries = document.querySelectorAll(".outline-3");

          entries.forEach((entry, index) => {
            // Extract the anchor ID from the container before transformation
            const anchorId = extractIdFromContainer(entry);

            // Extract components
            const h3 = entry.querySelector("h3");
            const notes = entry.querySelector(".notes");
            const outlineText = entry.querySelector(".outline-text-3");
            const tag = entry.querySelector(".tag");

            if (!h3 || !outlineText) return;

            // Get title text (preserve any TODO/DONE prefixes and links)
            let titleText = h3.innerHTML;

            // Get timestamp
            let timestampText = "";
            if (notes) {
              const timestamp = notes.querySelector(".timestamp");
              if (timestamp) {
                timestampText = timestamp.textContent;
              }
            }

            // Get content paragraphs (excluding notes, tag, and backlinks)
            const contentParagraphs = [];
            const blockElements = [];
            const backlinks = entry.querySelector(".BACKLINKS");

            Array.from(outlineText.children).forEach((child) => {
              if (
                child.classList.contains("notes") ||
                child.classList.contains("tag") ||
                child.classList.contains("BACKLINKS")
              ) {
                return; // Skip these - they'll be handled separately
              }

              if (child.tagName === "P") {
                contentParagraphs.push(child.innerHTML);
              } else if (
                child.tagName === "UL" ||
                child.tagName === "OL" ||
                child.tagName === "BLOCKQUOTE" ||
                child.tagName === "PRE" ||
                child.tagName === "DL" ||
                child.classList.contains("epigraph")
              ) {
                blockElements.push(child.outerHTML);
              } else if (
                child.tagName === "DIV" &&
                child.classList.contains("epigraph")
              ) {
                blockElements.push(child.outerHTML);
              }
            });

            // Get tag HTML (preserve links and formatting)
            let tagHtml = "";
            if (tag) {
              tagHtml = tag.outerHTML;
            }

            // Construct the new single paragraph
            let newContent = "";

            // Add date at the start (gray)
            if (timestampText) {
              newContent +=
                '<span class="entry-date">' + timestampText + "</span>";
            }

            // Add title with emdash
            newContent += titleText + " — ";

            // Add content paragraphs
            newContent += contentParagraphs.join(" ");

            // Add tag at the end in parentheses (preserve HTML but force inline)
            if (tagHtml) {
              // Extract just the inner content and wrap it properly
              let tagContent = tag.innerHTML;
              newContent +=
                ' <span class="entry-tag">(' + tagContent + ")</span>";
            }

            // Create new paragraph element
            const newParagraph = document.createElement("p");
            newParagraph.className = "entry-paragraph";
            newParagraph.innerHTML = newContent;

            // Clear the entry
            entry.innerHTML = "";

            // Preserve the anchor ID by setting it on the transformed entry
            if (anchorId) {
              entry.id = anchorId;
            }

            // Add backlinks FIRST so they can float to the right
            if (backlinks) {
              entry.appendChild(backlinks.cloneNode(true));
            }

            // Then add the main paragraph
            entry.appendChild(newParagraph);

            // Add any block elements after the paragraph
            blockElements.forEach((blockHtml) => {
              const blockDiv = document.createElement("div");
              blockDiv.className = "moved-block";
              blockDiv.innerHTML = blockHtml;
              entry.appendChild(blockDiv);
            });

            // Add separator after each entry (except the last one)
            if (index < entries.length - 1) {
              const separator = document.createElement("hr");
              separator.style.margin = "1em 0";
              separator.style.border = "none";
              separator.style.borderTop = "1px solid #ccc";
              entry.appendChild(separator);
            }
          });
        }

        // Initialize when DOM is ready
        function init() {
          addStyles();

          if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", applyFormatting);
          } else {
            applyFormatting();
          }
        }

        // Start the initialization
        init();
      })();
    </script>
  </head>
  <body></body>
</html>
</head>
<body>
<div id="preamble" class="status">
<div id="preamble" class="status">
  <div class="header" style="
    display: block !important;!i;!;
">
<a href="/">
<h1 class="title" style="
margin-block-start: auto;
    color: black;
">Hereby, all birds fly</h1>
      </a>
      <nav class="site-nav">
        <a href="/~saleh/p/">all posts</a>
        <span>•</span>
        <a href="/~saleh/stack.html">short posts</a>
        <span>•</span>
        <a href="/~saleh/fullbooks.html">books</a>
        <span>•</span>
        <a href="/~saleh/a.html#2ar8en10n2k0">anthology</a>
        <span>•</span>
        <a href="/~saleh/pgp.html">PGP key</a>
        <span>•</span>
        <a href="https://www.admonymous.co/larrasket">leave a message</a>
      </nav>
<hr class="header-divider" style="margin-block-end: -1em;">
  </div>
</div>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Effective Go: A Conclusion</h1>
</header><div class="propert" id="org9655472">
<p>
Part of a series on <a href="../cs/go.html#lvkhzyo02wj0">The Go Programming Language</a>
</p>

</div>


<div class="PREVIEW" id="org44df57e">
<p>
Reading the effective Go document.
</p>

</div>



<p>
So I&rsquo;m currently reading the effective Go docs (as <a href="https://go.dev/doc/effective_go">html</a>, as <a href="http://www.math.bas.bg/bantchev/place/go/effective-go.pdf">pdf</a>).
</p>

<p>
Years ago when I was learning C, I remember reading something similar, it was by
google as well. And I think they used to name it &rsquo;effective&rsquo; too. It was hosted
on github pages by Google and was advocated as the &ldquo;google-style guidelines&rdquo;.
Moreover, it had the same problem that I&rsquo;m facing with effective-go right now:
there are many things that have nothing to do with the go programming language
itself, but a general guidelines that you should probably have learned during
the design principles class. I decided to filter out those irrelevant tips and
distill a consultation, a recapitulation. So it might help someone.
</p>


<p>
References are used for non-tl;dr that might be interesting for nerds.<label for="1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="1" class="margin-toggle"/><span class="sidenote">
I also might use <a href="https://github.com/golang/go/wiki/CodeReview">https://github.com/golang/go/wiki/CodeReview</a>
</span>
</p>
<div id="outline-container-org6840d92" class="outline-2">
<h2 id="org6840d92">Naming</h2>
<div class="outline-text-2" id="text-org6840d92">
<p>
Names are as important in Go as in any other language. They even have semantic effect: the
visibility of a name outside a package is determined by whether its first character is upper
case. It&rsquo;s therefore worth spending a little time talking about naming conventions in Go
programs.
</p>
</div>
<div id="outline-container-orgecc2b4b" class="outline-3">
<h3 id="orgecc2b4b">Packages</h3>
<div class="outline-text-3" id="text-orgecc2b4b">
<p>
package in <code>src/pkg/encoding/base64</code> is imported as &ldquo;<code>encoding/base64</code>&rdquo; but has name <code>base64</code>,
<b>not</b> <code>encoding_base64</code> and not <code>encodingBase64</code>. The importer of a package will use the name to
refer to its contents (the import . notation is
</p>
</div>
</div>
<div id="outline-container-orgdf69de7" class="outline-3">
<h3 id="orgdf69de7">Getters</h3>
<div class="outline-text-3" id="text-orgdf69de7">
<p>
Go doesn&rsquo;t provide automatic support for getters and setters. There&rsquo;s nothing wrong with
providing getters and setters yourself, and it&rsquo;s often appropriate to do so, but it&rsquo;s
neither idiomatic nor necessary to put <code>Get</code> into the getter&rsquo;s name. If you have a field
called <code>owner</code> (lower case, unexported), the getter method should be called <code>Owner</code> (upper
case, exported), not <code>GetOwner</code>. The use of upper-case names for export provides the hook to
discriminate the field from the method. A setter function, if needed, will likely be called
<code>SetOwner</code>. Both names read well in practice:
</p>


<pre class="example" id="orgdf85d4a">
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
</pre>
</div>
</div>
<div id="outline-container-org3ebe3a4" class="outline-3">
<h3 id="org3ebe3a4">Interface (single-method)</h3>
<div class="outline-text-3" id="text-org3ebe3a4">
<p>
By convention, one-method interfaces are named by the method name plus an -er suffix or
similar modification to construct an agent noun: <code>Reader</code>, <code>Writer</code>, <code>Formatter</code>,
<code>CloseNotifier</code> etc.
</p>

<p>
There are a number of such names and it&rsquo;s productive to honor them and the function names
they capture. <code>Read</code>, <code>Write</code>, <code>Close</code>, <code>Flush</code>, <code>String</code> and so on have canonical
signatures and meanings. To avoid confusion, don&rsquo;t give your method one of those names
unless it has the same signature and meaning. Conversely, if your type implements a method
with the same meaning as a method on a well-known type, give it the same name and signature;
call your string-converter method <code>String</code> not <code>ToString</code>.
</p>
</div>
</div>
<div id="outline-container-org9d7dc79" class="outline-3">
<h3 id="org9d7dc79">MixedCaps</h3>
<div class="outline-text-3" id="text-org9d7dc79">
<p>
Finally, the convention in Go is to use <code>MixedCaps</code> or <code>mixedCaps</code> rather than underscores
to write multiword names.
</p>
</div>
</div>
</div>
<div id="outline-container-orgbe170e4" class="outline-2">
<h2 id="orgbe170e4">Comments</h2>
<div class="outline-text-2" id="text-orgbe170e4">
<p>
“Doc comments” are comments that appear immediately before top-level package, const, func,
type, and var declarations with no intervening newlines. Every exported (capitalized) name
should have a doc comment.
</p>

<p>
For syntax, read: <a href="https://go.dev/doc/comment#Syntax">https://go.dev/doc/comment#Syntax</a>
</p>
</div>
<div id="outline-container-orgda406bb" class="outline-3">
<h3 id="orgda406bb">Inside packages</h3>
<div class="outline-text-3" id="text-orgda406bb">
<p>
Every package should have a package comment introducing the package. It provides information relevant to the package as a whole and generally sets expectations for the package. Especially in large packages, it can be helpful for the package comment to give a brief overview of the most important parts of the API, linking to other doc comments as needed.
</p>

<p>
If the package is simple, the package comment can be brief. For example:
</p>

<pre class="example" id="orgb4b8eed">
// Package path implements utility routines for manipulating slash-separated
// paths.
//
// The path package should only be used for paths separated by forward
// slashes, such as the paths in URLs. This package does not deal with
// Windows paths with drive letters or backslashes; to manipulate
// operating system paths, use the [path/filepath] package.
package path
</pre>
</div>
</div>
<div id="outline-container-org623304a" class="outline-3">
<h3 id="org623304a"><span class="done KILL">KILL</span> Commands</h3>
</div>
<div id="outline-container-orgbd084c7" class="outline-3">
<h3 id="orgbd084c7"><code>type</code></h3>
<div class="outline-text-3" id="text-orgbd084c7">
<p>
A type&rsquo;s doc comment should explain what each instance of that type represents or provides.
If the API is simple, the doc comment can be quite short. For example:
</p>

<pre class="example" id="orgf2e6b31">
package zip

// A Reader serves content from a ZIP archive.
type Reader struct {
    ...
}
</pre>



<p>
By default, programmers should expect that a type is safe for use only by a single goroutine
at a time. If a type provides stronger guarantees, the doc comment should state them. For
example:
</p>


<pre class="example" id="orgc1a8ab8">
package regexp

// Regexp is the representation of a compiled regular expression.
// A Regexp is safe for concurrent use by multiple goroutines,
// except for configuration methods, such as Longest.
type Regexp struct {
    ...
}
</pre>



<p>
For a struct with exported fields, either the doc comment or per-field comments should
explain the meaning of each exported field. For example, this type&rsquo;s doc comment explains
the fields:
</p>

<pre class="example" id="orga64d68c">
 package io

// A LimitedReader reads from R but limits the amount of
// data returned to just N bytes. Each call to Read
// updates N to reflect the new amount remaining.
// Read returns EOF when N &lt;= 0.
type LimitedReader struct {
    R   Reader // underlying reader
    N   int64  // max bytes remaining
}
</pre>

<p>
As with packages (above) and funcs (below), doc comments for types <b>start with complete
sentences naming the declared symbol</b>. An explicit subject often makes the wording clearer,
and it makes the text easier to search, whether on a web page or a command line.
</p>
</div>
</div>
<div id="outline-container-org3ba1bba" class="outline-3">
<h3 id="org3ba1bba"><code>func</code></h3>
<div class="outline-text-3" id="text-org3ba1bba">
<p>
A func&rsquo;s doc comment should explain what the function returns or, for functions called for
side effects, what it does. Named arguments or results can be referred to directly in the
comment, without any special syntax like backquotes. (A consequence of this convention is
that names like <code>a</code>, which might be mistaken for ordinary words, are typically avoided.) For
example:
</p>


<pre class="example" id="org2a04cf2">
 package strconv

// Quote returns a double-quoted Go string literal representing s.
// The returned string uses Go escape sequences (\t, \n, \xFF, \u0100)
// for control characters and non-printable characters as defined by IsPrint.
func Quote(s string) string {
    ...
}
</pre>
</div>
</div>
<div id="outline-container-org0d06766" class="outline-3">
<h3 id="org0d06766"><code>const</code></h3>
<div class="outline-text-3" id="text-org0d06766">
<p>
Go&rsquo;s declaration syntax allows grouping of declarations, in which case a single doc comment
can introduce a group of related constants, with individual constants only documented by
short end-of-line comments. For example:
</p>
<pre class="code"><code><span style="color: #556b2f;">// </span><span style="color: #556b2f;">The result of Scan is one of these tokens or a Unicode character.
</span><span style="color: #ffad29; font-weight: bold;">const</span> (
    <span style="color: #383a42;">EOF</span> = -(<span style="color: #383a42;">iota</span> + 1)
    <span style="color: #383a42;">Ident</span>
    <span style="color: #383a42;">Int</span>
    <span style="color: #383a42;">Float</span>
    <span style="color: #383a42;">Char</span>
    ...
)
</code></pre>


<p>
Sometimes the group needs no doc comment at all. For example:
</p>

<pre class="example" id="orgc1b49ba">
 package unicode // import "unicode"

const (
    MaxRune         = '\U0010FFFF' // maximum valid Unicode code point.
    ReplacementChar = '\uFFFD'     // represents invalid code points.
    MaxASCII        = '\u007F'     // maximum ASCII value.
    MaxLatin1       = '\u00FF'     // maximum Latin-1 value.
)
</pre>



<p>
On the other hand, ungrouped constants typically warrant a full doc comment starting with a complete sentence. For example:
</p>

<pre class="example" id="org8a48007">
 package unicode

// Version is the Unicode edition from which the tables are derived.
const Version = "13.0.0"
</pre>
</div>
</div>
<div id="outline-container-orgf1892c1" class="outline-3">
<h3 id="orgf1892c1"><code>var</code></h3>
</div>
</div>
<div id="outline-container-org6aae105" class="outline-2">
<h2 id="org6aae105">CHECK Errors</h2>
<div class="outline-text-2" id="text-org6aae105">
</div>
<div id="outline-container-orgcaf9100" class="outline-3">
<h3 id="orgcaf9100">Error Strings</h3>
<div class="outline-text-3" id="text-orgcaf9100">
<p>
Error strings should not be capitalized (unless beginning with proper nouns or acronyms) or
end with punctuation, since they are usually printed following other context. That is, use
<code>fmt.Errorf("something bad")</code> not <code>fmt.Errorf("Something bad")</code>, so that <code>log.Printf("Reading %s:
%v", filename, err)</code> formats without a spurious capital letter mid-message. This does not
apply to logging, which is implicitly line-oriented and not combined inside other messages.
</p>
</div>
</div>
</div>
<div id="outline-container-org688e999" class="outline-2">
<h2 id="org688e999">Other</h2>
<div class="outline-text-2" id="text-org688e999">
</div>
<div id="outline-container-org3277159" class="outline-3">
<h3 id="org3277159">Semicolons</h3>
<div class="outline-text-3" id="text-org3277159">
<p>
Idiomatic Go programs have semicolons only in places such as <code>for</code> loop clauses, to separate
the initializer, condition, and continuation elements. They are also necessary to separate
multiple statements on a line, should you write code that way<label for="2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="2" class="margin-toggle"/><span class="sidenote">
One consequence of the semicolon insertion rules is that you cannot put the opening brace of
a control structure ( <code>if</code>, <code>for</code>, <code>switch</code>, or <code>select</code>) on the next line. If you do, a
semicolon will be inserted before the brace, which could cause unwanted effects. Write them
like this



if i &lt; f() {
    g()
}



not like this



if i &lt; f()  // wrong!
{           // wrong!
    g()
}
</span>.
</p>
</div>
</div>
<div id="outline-container-org3aa03dd" class="outline-3">
<h3 id="org3aa03dd">Declaring Variables</h3>
<div class="outline-text-3" id="text-org3aa03dd">
<ul class="org-ul">
<li>When declaring —but not initializing— a variable, <b>use the keyword <code>var</code></b></li>
<li>When declaring and initializing in the same time, use the short declaration form: <code>:=</code></li>
</ul>

<p>
When declaring an empty slice, prefer
</p>
<pre class="code"><code><span style="color: #ffad29; font-weight: bold;">var</span> <span style="color: #383a42;">t</span> []<span style="color: #34cae2; font-weight: bold;">string</span>
</code></pre>
<p>
over
</p>
<pre class="code"><code><span style="color: #383a42;">t</span> := []<span style="color: #34cae2; font-weight: bold;">string</span>{}
</code></pre>

<p>
The former declares a nil slice value, while the latter is non-nil but zero-length. They are
functionally equivalent—their <code>len</code> and <code>cap</code> are both zero—but the nil slice is the preferred
style.
</p>


<p>
Note that there are limited circumstances where a non-nil but zero-length slice is
preferred, such as when encoding JSON objects (a nil slice encodes to null, while []string{}
encodes to the JSON array []).
</p>

<p>
When designing interfaces, avoid making a distinction between a nil slice and a non-nil,
zero-length slice, as this can lead to subtle programming errors.
</p>
</div>
</div>
<div id="outline-container-org6909e3f" class="outline-3">
<h3 id="org6909e3f">Context</h3>
<div class="outline-text-3" id="text-org6909e3f">
<p>
Values of the context.Context type carry security credentials, tracing information,
deadlines, and cancellation signals across API and process boundaries. Go programs pass
Contexts explicitly along the entire function call chain from incoming RPCs and HTTP
requests to outgoing requests.
</p>

<p>
<b>Most functions that use a Context should accept it as their first parameter:</b>
</p>

<pre class="code"><code><span style="color: #ffad29; font-weight: bold;">func</span> <span style="color: #00ede1; font-weight: bold;">F</span>(<span style="color: #383a42;">ctx</span> <span style="color: #34cae2; font-weight: bold;">context.Context</span>, <span style="color: #556b2f;">/* </span><span style="color: #556b2f;">other arguments */</span>) {}
</code></pre>

<p>
A function that is never request-specific may use context.Background(), but err on the side
of passing a Context even if you think you don&rsquo;t need to. The default case is to pass a
Context; only use context.Background() directly if you have a good reason why the
alternative is a mistake.
</p>

<p>
<b>Don&rsquo;t add a Context member to a struct type</b>; instead add a <code>ctx</code> parameter to each method on
that type that needs to pass it along. The one exception is for methods whose signature must
match an interface in the standard library or in a third party library.
</p>

<p>
Don&rsquo;t create custom Context types or use interfaces other than Context in function
signatures.
</p>

<p>
If you have application data to pass around, put it in a parameter, in the receiver, in
globals, or, if it truly belongs there, in a Context value.
</p>

<p>
Contexts are immutable, so it&rsquo;s fine to pass the same ctx to multiple calls that share the
same deadline, cancellation signal, credentials, parent trace, etc.
</p>
</div>
</div>
<div id="outline-container-org644a5c2" class="outline-3">
<h3 id="org644a5c2">Rand</h3>
<div class="outline-text-3" id="text-org644a5c2">
<p>
Do not use package <code>math/rand</code> to generate keys, even throwaway ones. Unseeded, the generator
is completely predictable. Seeded with <code>time.Nanoseconds()</code>, there are just a few bits of
entropy. Instead, use <code>crypto/rand</code>&rsquo;s Reader, and if you need text, print to hexadecimal or
<code>base64</code>:
</p>

<pre class="code"><code><span style="color: #ffad29; font-weight: bold;">import</span> (
    <span style="color: #8a3b3c;">"crypto/rand"</span>
    <span style="color: #556b2f;">// </span><span style="color: #556b2f;">"encoding/base64"
</span>    <span style="color: #556b2f;">// </span><span style="color: #556b2f;">"encoding/hex"
</span>    <span style="color: #8a3b3c;">"fmt"</span>
)

<span style="color: #ffad29; font-weight: bold;">func</span> <span style="color: #00ede1; font-weight: bold;">Key</span>() <span style="color: #34cae2; font-weight: bold;">string</span> {
    <span style="color: #383a42;">buf</span> := <span style="color: #23d7d7; font-weight: bold;">make</span>([]<span style="color: #34cae2; font-weight: bold;">byte</span>, 16)
    <span style="color: #383a42;">_</span>, <span style="color: #383a42;">err</span> := rand.<span style="color: #00ede1; font-weight: bold;">Read</span>(buf)
    <span style="color: #ffad29; font-weight: bold;">if</span> err != <span style="color: #383a42;">nil</span> {
        <span style="color: #23d7d7; font-weight: bold;">panic</span>(err)  <span style="color: #556b2f;">// </span><span style="color: #556b2f;">out of randomness, should never happen
</span>    }
    <span style="color: #ffad29; font-weight: bold;">return</span> fmt.<span style="color: #00ede1; font-weight: bold;">Sprintf</span>(<span style="color: #8a3b3c;">"%x"</span>, buf)
    <span style="color: #556b2f;">// </span><span style="color: #556b2f;">or hex.EncodeToString(buf)
</span>    <span style="color: #556b2f;">// </span><span style="color: #556b2f;">or base64.StdEncoding.EncodeToString(buf)
</span>}

<span style="color: #ffad29; font-weight: bold;">func</span> <span style="color: #00ede1; font-weight: bold;">main</span>() {
    fmt.<span style="color: #00ede1; font-weight: bold;">Print</span>(<span style="color: #00ede1; font-weight: bold;">Key</span>())
        }
</code></pre>
</div>
</div>
<div id="outline-container-org24c9fb1" class="outline-3">
<h3 id="org24c9fb1">Import Blank</h3>
<div class="outline-text-3" id="text-org24c9fb1">
<p>
Packages that are imported only for their side effects (using the syntax <code>import _ "pkg"</code>)
should only be imported in the main package of a program, or in tests that require them.
</p>
</div>
</div>
<div id="outline-container-org4232d2f" class="outline-3">
<h3 id="org4232d2f">Named Result Parameters</h3>
<div class="outline-text-3" id="text-org4232d2f">
<p>
Consider what it will look like in godoc. Named result parameters like:
</p>

<pre class="code"><code><span style="color: #ffad29; font-weight: bold;">func</span> (<span style="color: #383a42;">n</span> *<span style="color: #34cae2; font-weight: bold;">Node</span>) <span style="color: #00ede1; font-weight: bold;">Parent1</span>() (<span style="color: #383a42;">node</span> *<span style="color: #34cae2; font-weight: bold;">Node</span>) {}
<span style="color: #ffad29; font-weight: bold;">func</span> (<span style="color: #383a42;">n</span> *<span style="color: #34cae2; font-weight: bold;">Node</span>) <span style="color: #00ede1; font-weight: bold;">Parent2</span>() (<span style="color: #383a42;">node</span> *<span style="color: #34cae2; font-weight: bold;">Node</span>, <span style="color: #383a42;">err</span> <span style="color: #34cae2; font-weight: bold;">error</span>) {}
</code></pre>
<p>
will be repetitive in godoc; better to use:
</p>

<pre class="code"><code><span style="color: #ffad29; font-weight: bold;">func</span> (<span style="color: #383a42;">n</span> *<span style="color: #34cae2; font-weight: bold;">Node</span>) <span style="color: #00ede1; font-weight: bold;">Parent1</span>() *<span style="color: #34cae2; font-weight: bold;">Node</span> {}
<span style="color: #ffad29; font-weight: bold;">func</span> (<span style="color: #383a42;">n</span> *<span style="color: #34cae2; font-weight: bold;">Node</span>) <span style="color: #00ede1; font-weight: bold;">Parent2</span>() (*<span style="color: #34cae2; font-weight: bold;">Node</span>, <span style="color: #34cae2; font-weight: bold;">error</span>) {}
</code></pre>

<p>
On the other hand, if a function returns two or three parameters of the same type, or if the
meaning of a result isn&rsquo;t clear from context, adding names may be useful in some contexts.
<b>Don&rsquo;t name result parameters just to avoid declaring a var inside the function; that trades
off a minor implementation brevity at the cost of unnecessary API verbosity.</b>
</p>
</div>
</div>
<div id="outline-container-org4eb5121" class="outline-3">
<h3 id="org4eb5121">Return Values</h3>
<div class="outline-text-3" id="text-org4eb5121">
<ul class="org-ul">
<li>If the receiver is a <code>map</code>, <code>func</code> or <code>chan</code>, don&rsquo;t use a pointer to them. If the receiver is a
slice and the method doesn&rsquo;t reslice or reallocate the slice, don&rsquo;t use a pointer to it.</li>

<li>If the method needs to mutate the receiver, the receiver must be a pointer.</li>

<li>If the receiver is a <code>struct</code> that contains a sync.Mutex or similar synchronizing field, the
receiver must be a pointer to avoid copying.</li>

<li>If the receiver is a large <code>struct</code> or array, a pointer receiver is more efficient. How
large is large? Assume it&rsquo;s equivalent to passing all its elements as arguments to the
method. If that feels too large, it&rsquo;s also too large for the receiver.</li>

<li>Can function or methods, either concurrently or when called from this method, be mutating
the receiver? A value type creates a copy of the receiver when the method is invoked, so
outside updates will not be applied to this receiver. If changes must be visible in the
original receiver, the receiver must be a pointer.</li>

<li>If the receiver is a <code>struct</code>, array or slice and any of its elements is a pointer to
something that might be mutating, prefer a pointer receiver, as it will make the intention
clearer to the reader.</li>

<li>If the receiver is a small array or <code>struct</code> that is naturally a value type (for instance,
something like the time.Time type), with no mutable fields and no pointers, or is just a
simple basic type such as int or string, a value receiver makes sense. A value receiver
can reduce the amount of garbage that can be generated; if a value is passed to a value
method, an on-stack copy can be used instead of allocating on the heap. (The compiler
tries to be smart about avoiding this allocation, but it can&rsquo;t always succeed.) Don&rsquo;t
choose a value receiver type for this reason without profiling first.</li>

<li>Don&rsquo;t mix receiver types. Choose either pointers or <code>struct</code> types for all available
methods.</li>

<li>Finally, when in doubt, use a pointer receiver.</li>
</ul>
</div>
</div>
<div id="outline-container-org6e9bd32" class="outline-3">
<h3 id="org6e9bd32"><span class="done KILL">KILL</span> Interfaces</h3>
<div class="outline-text-3" id="text-org6e9bd32">
<p>
Go interfaces generally belong in the package that uses values of the interface type, not
the package that implements those values. The implementing package should return concrete
(usually pointer or struct) types: that way, new methods can be added to implementations
without requiring extensive refactoring.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
I also might use <a href="https://github.com/golang/go/wiki/CodeReview">https://github.com/golang/go/wiki/CodeReview</a>
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">
One consequence of the semicolon insertion rules is that you cannot put the opening brace of
a control structure ( <code>if</code>, <code>for</code>, <code>switch</code>, or <code>select</code>) on the next line. If you do, a
semicolon will be inserted before the brace, which could cause unwanted effects. Write them
like this
</p>

<pre class="example" id="org8073d73">
if i &lt; f() {
    g()
}
</pre>

<p class="footpara">
not like this
</p>

<pre class="example" id="orgbdb66e7">
if i &lt; f()  // wrong!
{           // wrong!
    g()
}
</pre></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<div id="postamble" class="status">
<hr style="
    clear: both;
">

  <div class="book-covers" style="margin: 1em 0; padding: 0 10px;">
    <p style="margin: 0.5em 0; font-style: italic; color: #555;">Some works I recommend engaging with:</p>
    <div id="books-container" style="display: flex; flex-wrap: wrap; gap: 8px; max-width: 100%;"></div>
  </div>


  <script>
    const path = window.location.pathname;
    if (path !== '/' && path !== '/index.html') {
      const allBooks = [
        {title: 'The Computational Beauty of Nature', author: 'Gary William Flake'},
        {title: 'Group Psychology', author: 'Sigmund Freud'},
        {title: 'Logic', author: 'Nicholas Smith'},
        {title: 'Structure and Interpretation of Computer Programs', author: 'Harold Abelson'},
        {title: 'The C Programming Language', author: 'Brian Kernighan'},
        {title: 'Out of Bounds: Academic Freedom and the Question of Palestine', author: 'M. Abraham'},
        {title: 'Understanding Power: The Indispensable Chomsky', author: 'Noam Chomsky'},
        {title: 'Who Rules the World?', author: 'Noam Chomsky'},
        {title: 'Manufacturing Consent: The Political Economy of the Mass Media', author: 'Noam Chomsky'},
        {title: 'A People History of The World', author: 'Chris Harman'},
        {title: 'The Arabs: A History', author: 'Eugene Rogan'},
        {title: 'State of Terror', author: 'Y. Suarez'},
        {title: 'A People History of The United States', author: 'Howard Zinn'},
        {title: 'Killing Hope', author: 'William Blum'},
        {title: 'Deliverance From Error', author: 'Al-Ghazali'},
        {title: 'The Dawn of The Day', author: 'Friedrich Nietzsche'},
        {title: 'Islam and The Destiny of Man', author: 'Gai Eaton'},
        {title: 'The Polymath', author: 'Waqas Ahmed'},
        {title: 'Twilight of The Idols', author: 'Friedrich Nietzsche'},
        {title: 'Manfred', author: 'Lord Byron'},
        {title: 'Marx in Soho', author: 'Howard Zinn'}
      ];

      const shuffled = allBooks.sort(() => 0.5 - Math.random());
      const container = document.getElementById('books-container');
      let displayedBooks = 0;
      let bookIndex = 0;

      async function tryNextBook() {
        if (displayedBooks >= 2 || bookIndex >= shuffled.length) return;

        const book = shuffled[bookIndex];
        bookIndex++;

        try {
          const res = await fetch(`https://www.googleapis.com/books/v1/volumes?q=intitle:${encodeURIComponent(book.title)}+inauthor:${encodeURIComponent(book.author)}&maxResults=1`);
          const data = await res.json();

          if (data.items && data.items[0]) {
            const volumeInfo = data.items[0].volumeInfo;
            if (volumeInfo.imageLinks) {
              const link = document.createElement('a');
              link.style.display = 'none';
              link.style.lineHeight = '0';
              link.target = '_blank';
              if (volumeInfo.infoLink) {
                link.href = volumeInfo.infoLink;
              }

              const img = document.createElement('img');
              img.style.cssText = 'height: 140px; border: 1px dotted #666; background: transparent;';
              img.src = volumeInfo.imageLinks.thumbnail;
              img.onload = () => {
                link.style.display = 'inline-block';
              };

              link.appendChild(img);
              container.appendChild(link);
              displayedBooks++;
              
              if (displayedBooks < 2) {
                tryNextBook();
              }
            } else {
              console.log(`Cannot find book cover for: ${book.title} by ${book.author}`);
              tryNextBook();
            }
          } else {
            console.log(`Cannot find book: ${book.title} by ${book.author}`);
            tryNextBook();
          }
        } catch (err) {
          console.log(`Error fetching book: ${book.title} by ${book.author}`, err);
          tryNextBook();
        }
      }

      tryNextBook();
    } else {
      document.querySelector('.book-covers').style.display = 'none';
    }
  </script>

  </div>



<p> I seek refuge in God, from Satan the rejected. Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 30.2 (<a href="https://orgmode.org">Org</a> mode 9.7.34). Written by: Salih Muhammed, by the date of: 2022-09-20 Tue 03:20. Last build date: 2025-11-07 Fri 20:38.</p>




</div>
</div>
</body>
</html>
