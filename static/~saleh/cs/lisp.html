<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lisp Programming Language</title>
<meta name="author" content="Salih Muhammed" />
<meta name="generator" content="Org Mode" />
<!doctype html>
<html>
  <head>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Amiri:ital,wght@0,400;0,700;1,400;1,700&family=Arimo:ital,wght@0,400..700;1,400..700&display=swap"
      rel="stylesheet"
    />
    <meta name="theme-color" content="#ffffff" />
    <meta charset="utf-8" />
    <meta name="theme-color" content="#ffffff" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="/~saleh/style/toc.css?v=20250130" />
    <link rel="stylesheet" href="/~saleh/style/tufte.css?v=20250130" />
    <link rel="stylesheet" href="/~saleh/style/main.css?v=20250230" />

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const p = document.querySelector("#content > p:first-of-type");
        if (p && /^[\u0600-\u06FF]/.test(p.textContent.trim())) {
          p.classList.add("arabic");
        }
      });
    </script>

    <script async data-id="101390423" src="//static.getclicky.com/js"></script>
    <noscript>
      <p>
        <img
          alt="Clicky"
          width="1"
          height="1"
          src="//in.getclicky.com/101390423ns.gif"
        /></p
    ></noscript>

    <!-- Import LazySizes - State-of-the-art lazy loading library -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/lazysizes.min.js"
      async
    ></script>

    <!-- Optional: Import plugins for better performance -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/plugins/unveilhooks/ls.unveilhooks.min.js"
      async
    ></script>

    <script>
      // Only run on pages with 'art_paintings_media' in the path
      if (window.location.pathname.includes("art_paintings_media")) {
        document.addEventListener("DOMContentLoaded", function () {
          // Configure LazySizes for optimal performance
          window.lazySizesConfig = window.lazySizesConfig || {};
          window.lazySizesConfig.loadMode = 1; // Load images one at a time for better performance
          window.lazySizesConfig.expand = 50; // Load images 50px before they enter viewport
          window.lazySizesConfig.expFactor = 1.5; // Expand loading area
          window.lazySizesConfig.hFac = 0.4; // Height factor for loading trigger

          // Add CSS for smooth transitions and collapsible content
          const style = document.createElement("style");
          style.textContent = `
      .lazyload,
      .lazyloading {
        opacity: 0;
        transition: opacity 0.4s ease-in-out;
      }
      .lazyloaded {
        opacity: 1;
      }
      .collapsible-content {
        overflow: hidden;
        transition: max-height 0.3s ease-out;
      }
      .collapsible-content.collapsed {
        max-height: 0 !important;
      }
      .collapsible-content.expanded {
        max-height: none;
      }
      /* Blur effect while loading (optional) */
      .lazyloading {
        filter: blur(5px);
        opacity: 0.7;
      }
      .lazyloaded {
        filter: none;
      }
    `;
          document.head.appendChild(style);

          // Find all h3 elements
          const h3Elements = document.querySelectorAll("h3");

          h3Elements.forEach(function (h3) {
            // Make h3 clickable and add icon
            h3.style.position = "relative";
            h3.style.cursor = "pointer";
            h3.style.paddingLeft = "20px";
            h3.style.userSelect = "none";

            // Add the arrow icon
            const icon = document.createElement("span");
            icon.innerHTML = "▶";
            icon.style.position = "absolute";
            icon.style.left = "0px";
            icon.style.top = "50%";
            icon.style.transform = "translateY(-50%)";
            icon.style.transition = "transform 0.2s";
            icon.style.fontSize = "0.8em";
            icon.style.color = "rgb(102, 102, 102)";
            icon.style.fontFamily = "monospace";

            h3.insertBefore(icon, h3.firstChild);

            // Find all content after this h3 until the next h3 or end of parent
            const contentElements = [];
            let nextElement = h3.nextElementSibling;

            while (nextElement && nextElement.tagName !== "H3") {
              contentElements.push(nextElement);
              nextElement = nextElement.nextElementSibling;
            }

            // Create a wrapper for smooth collapsing
            const wrapper = document.createElement("div");
            wrapper.className = "collapsible-content collapsed";
            wrapper.style.maxHeight = "0";

            // Move content elements into wrapper
            contentElements.forEach(function (element) {
              wrapper.appendChild(element);
            });

            // Insert wrapper after h3
            h3.parentNode.insertBefore(wrapper, h3.nextSibling);

            // Prepare images for LazySizes lazy loading and make them clickable
            const prepareImagesForLazyLoading = (container) => {
              const images = container.querySelectorAll("img");
              images.forEach(function (img) {
                // Only process if not already processed
                if (
                  !img.classList.contains("lazyload") &&
                  !img.dataset.processed
                ) {
                  // Store original src in data-src for LazySizes
                  if (
                    img.src &&
                    img.src !== "" &&
                    !img.src.startsWith("data:")
                  ) {
                    img.dataset.src = img.src;
                    // Use a tiny placeholder or low-quality placeholder
                    img.src =
                      'data:image/svg+xml,%3Csvg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1 1"%3E%3Crect width="1" height="1" fill="%23f0f0f0"/%3E%3C/svg%3E';
                  }

                  // Handle srcset for responsive images
                  if (img.srcset && img.srcset !== "") {
                    img.dataset.srcset = img.srcset;
                    img.srcset = "";
                  }

                  // Handle sizes attribute
                  if (img.sizes) {
                    img.dataset.sizes = img.sizes;
                  }

                  // Add LazySizes classes
                  img.classList.add("lazyload");

                  // Make image clickable - add cursor pointer
                  img.style.cursor = "pointer";

                  // Add click handler to open image in new tab
                  img.addEventListener("click", function (e) {
                    e.preventDefault();
                    e.stopPropagation(); // Prevent triggering h3 collapse

                    // Get the actual image URL (either from src or data-src)
                    let imageUrl = this.src;
                    if (this.dataset.src && !this.src.startsWith("data:")) {
                      imageUrl = this.dataset.src;
                    } else if (
                      this.src.startsWith("data:") &&
                      this.dataset.src
                    ) {
                      imageUrl = this.dataset.src;
                    }

                    // Open image in new tab
                    if (imageUrl && !imageUrl.startsWith("data:")) {
                      window.open(imageUrl, "_blank");
                    }
                  });

                  // Mark as processed
                  img.dataset.processed = "true";

                  // Maintain aspect ratio to prevent layout shift
                  if (!img.style.aspectRatio && img.width && img.height) {
                    img.style.aspectRatio = img.width + "/" + img.height;
                  }
                }
              });
            };

            // Prepare all images in this section for lazy loading
            prepareImagesForLazyLoading(wrapper);

            // Track collapsed state
            let isCollapsed = true;
            let hasBeenExpanded = false;

            // Add click handler
            h3.addEventListener("click", function (e) {
              e.preventDefault();

              if (isCollapsed) {
                // Expand: show content and activate lazy loading
                icon.style.transform = "translateY(-50%) rotate(90deg)";
                wrapper.classList.remove("collapsed");
                wrapper.classList.add("expanded");
                wrapper.style.maxHeight = wrapper.scrollHeight + "px";

                // Only activate LazySizes for this section when first expanded
                if (!hasBeenExpanded) {
                  // Trigger LazySizes to check for images in this newly visible section
                  if (window.lazySizes) {
                    // Force LazySizes to check all images in this wrapper
                    const lazyImages = wrapper.querySelectorAll(".lazyload");
                    lazyImages.forEach((img) => {
                      // Add to LazySizes queue
                      window.lazySizes.loader.unveil(img);
                    });
                  }
                  hasBeenExpanded = true;
                }

                isCollapsed = false;

                // Recalculate height after images potentially load
                setTimeout(() => {
                  if (!isCollapsed) {
                    wrapper.style.maxHeight = wrapper.scrollHeight + "px";
                  }
                }, 100);
              } else {
                // Collapse: hide content
                icon.style.transform = "translateY(-50%) rotate(0deg)";
                wrapper.classList.remove("expanded");
                wrapper.classList.add("collapsed");
                wrapper.style.maxHeight = "0";

                isCollapsed = true;
              }
            });

            // Listen for LazySizes events to adjust height dynamically
            wrapper.addEventListener("lazyloaded", function (e) {
              if (!isCollapsed) {
                // Adjust wrapper height when images load
                setTimeout(() => {
                  wrapper.style.maxHeight = wrapper.scrollHeight + "px";
                }, 50);
              }
            });
          });
        });
      }
    </script>

    <script>
      (function () {
        "use strict";

        // Check if current page should have the formatting applied
        function shouldApplyFormatting() {
          const path = window.location.pathname;

          // Check if path matches our target patterns
          return (
            path === "/~saleh/stack" ||
            path === "/~saleh/stack.html" ||
            path.startsWith("/~saleh/sh/")
          );
        }

        // Only proceed if we're on a target page
        if (!shouldApplyFormatting()) {
          return;
        }

        // Add CSS styles
        function addStyles() {
          const style = document.createElement("style");
          style.textContent = `
      /* Basic styling for entries */
      .outline-3 {
        margin-bottom: 1.5em;
        line-height: 1.5;
      }

      /* Style for reconstructed single paragraph */
      .entry-paragraph {
        margin: 0;
        line-height: 1.5;
        direction: inherit;
        unicode-bidi: plaintext;
      }

      /* Style for date - gray and nice */
      .entry-date {
        color: #666;
        font-size: 0.9em;
        margin-right: 0.5em;
      }

      /* Style for tag at end - gray and in parentheses */
      .entry-tag {
        display: inline !important;
        color: #666;
        margin-left: 0.5em;
      }

      /* Ensure all children stay inline */
      .entry-tag * {
        display: inline !important;
      }

      /* Override any existing tag styles */
      .entry-tag p,
      .entry-tag div {
        display: inline !important;
        margin: 0 !important;
        padding: 0 !important;
      }


      /* Hide block elements that will be moved */
      .outline-3 .moved-block {
        display: block;
        margin: 0.5em 0;
      }

      /* Ensure proper anchor target visibility */
      .outline-3[id] {
        scroll-margin-top: 20px;
      }
    `;
          document.head.appendChild(style);
        }

        // Extract ID from container div
        function extractIdFromContainer(entry) {
          const containerId = entry.id;
          if (containerId && containerId.startsWith("outline-container-")) {
            return containerId.replace("outline-container-", "");
          }
          return null;
        }

        // Apply the formatting transformation
        function applyFormatting() {
          // Process each entry
          const entries = document.querySelectorAll(".outline-3");

          entries.forEach((entry, index) => {
            // Extract the anchor ID from the container before transformation
            const anchorId = extractIdFromContainer(entry);

            // Extract components
            const h3 = entry.querySelector("h3");
            const notes = entry.querySelector(".notes");
            const outlineText = entry.querySelector(".outline-text-3");
            const tag = entry.querySelector(".tag");

            if (!h3 || !outlineText) return;

            // Get title text (preserve any TODO/DONE prefixes and links)
            let titleText = h3.innerHTML;

            // Get timestamp
            let timestampText = "";
            if (notes) {
              const timestamp = notes.querySelector(".timestamp");
              if (timestamp) {
                timestampText = timestamp.textContent;
              }
            }

            // Get content paragraphs (excluding notes, tag, and backlinks)
            const contentParagraphs = [];
            const blockElements = [];
            const backlinks = entry.querySelector(".BACKLINKS");

            Array.from(outlineText.children).forEach((child) => {
              if (
                child.classList.contains("notes") ||
                child.classList.contains("tag") ||
                child.classList.contains("BACKLINKS")
              ) {
                return; // Skip these - they'll be handled separately
              }

              if (child.tagName === "P") {
                contentParagraphs.push(child.innerHTML);
              } else if (
                child.tagName === "UL" ||
                child.tagName === "OL" ||
                child.tagName === "BLOCKQUOTE" ||
                child.tagName === "PRE" ||
                child.tagName === "DL" ||
                child.classList.contains("epigraph")
              ) {
                blockElements.push(child.outerHTML);
              } else if (
                child.tagName === "DIV" &&
                child.classList.contains("epigraph")
              ) {
                blockElements.push(child.outerHTML);
              }
            });

            // Get tag HTML (preserve links and formatting)
            let tagHtml = "";
            if (tag) {
              tagHtml = tag.outerHTML;
            }

            // Construct the new single paragraph
            let newContent = "";

            // Add date at the start (gray)
            if (timestampText) {
              newContent +=
                '<span class="entry-date">' + timestampText + "</span>";
            }

            // Add title with emdash
            newContent += titleText + " — ";

            // Add content paragraphs
            newContent += contentParagraphs.join(" ");

            // Add tag at the end in parentheses (preserve HTML but force inline)
            if (tagHtml) {
              // Extract just the inner content and wrap it properly
              let tagContent = tag.innerHTML;
              newContent +=
                ' <span class="entry-tag">(' + tagContent + ")</span>";
            }

            // Create new paragraph element
            const newParagraph = document.createElement("p");
            newParagraph.className = "entry-paragraph";
            newParagraph.innerHTML = newContent;

            // Clear the entry
            entry.innerHTML = "";

            // Preserve the anchor ID by setting it on the transformed entry
            if (anchorId) {
              entry.id = anchorId;
            }

            // Add backlinks FIRST so they can float to the right
            if (backlinks) {
              entry.appendChild(backlinks.cloneNode(true));
            }

            // Then add the main paragraph
            entry.appendChild(newParagraph);

            // Add any block elements after the paragraph
            blockElements.forEach((blockHtml) => {
              const blockDiv = document.createElement("div");
              blockDiv.className = "moved-block";
              blockDiv.innerHTML = blockHtml;
              entry.appendChild(blockDiv);
            });

            // Add separator after each entry (except the last one)
            if (index < entries.length - 1) {
              const separator = document.createElement("hr");
              separator.style.margin = "1em 0";
              separator.style.border = "none";
              separator.style.borderTop = "1px solid #ccc";
              entry.appendChild(separator);
            }
          });
        }

        // Initialize when DOM is ready
        function init() {
          addStyles();

          if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", applyFormatting);
          } else {
            applyFormatting();
          }
        }

        // Start the initialization
        init();
      })();
    </script>
  </head>
  <body></body>
</html>
</head>
<body>
<div id="preamble" class="status">
<div id="preamble" class="status">
  <div class="header" style="
    display: block !important;!i;!;
">
<a href="/">
<h1 class="title" style="
margin-block-start: auto;
    color: black;
">Hereby, all birds fly</h1>
      </a>
      <nav class="site-nav">
        <a href="/~saleh/p/">all posts</a>
        <span>•</span>
        <a href="/~saleh/stack.html">short posts</a>
        <span>•</span>
        <a href="/~saleh/fullbooks.html">books</a>
        <span>•</span>
        <a href="/~saleh/a.html#2ar8en10n2k0">anthology</a>
        <span>•</span>
        <a href="/~saleh/pgp.html">PGP key</a>
        <span>•</span>
        <a href="https://www.admonymous.co/larrasket">leave a message</a>
      </nav>
<hr class="header-divider" style="margin-block-end: -1em;">
  </div>
</div>
</div>
<div id="content" class="content">
<header>
<h1 class="title">Lisp Programming Language</h1>
</header><div class="BACKLINKS" id="orga2aa78e">
<p>
This section was referenced in <a href="../cl.html#hol77960fwj0">Legacy Commentary</a>.
</p>

</div>

<div class="tag" id="orgb5e634c">
<p>
This section was labeled under, or is related to <a href="../t/programming.html#4u5664n02wj0">programming</a>.
</p>

</div>

<div class="PREVIEW" id="org5dc295d">
<p>
Tutorial on Lisp.
</p>

</div>


<p>
The Lisp programming language s a family of programming languages with a long history and a distinctive, fully parenthesized prefix notation. Originally specified in 1958, Lisp is the second-oldest high-level programming language still in common use. Only Fortran is older, by one year. Lisp has changed since its early days, and many dialects have existed over its history. Today, the best-known general-purpose Lisp dialects are Common Lisp, Scheme, Racket and Clojure.
</p>
<div id="outline-container-org73b527a" class="outline-2">
<h2 id="org73b527a">Choosing Implementation</h2>
<div class="outline-text-2" id="text-org73b527a">
<p>
The first thing you have to do is to choose a Lisp implementation. This may seem like a strange thing to have to do for folks used to languages such as Perl, Python, Visual Basic (VB), C#, and Java. The difference between Common Lisp and these languages is that Common Lisp is defined by its standard—there is neither a single implementation controlled by a benevolent dictator, as with Perl and Python, nor a canonical implementation controlled by a single company, as with VB, C#, and Java. Anyone who wants to read the standard and implement the language is free to do so. Furthermore, changes to the standard have to be made in accordance with a process controlled by the standards body American National Standards Institute (ANSI). That process is designed to keep any one entity, such as a single vendor, from being able to arbitrarily change the standard. Thus, the Common Lisp standard is a contract between any Common Lisp vendor and Common Lisp programmers. The contract tells you that if you write a program that uses the features of the language the way they’re described in the standard, you can count on your program behaving the same in any conforming implementation.
</p>
</div>
</div>
<div id="outline-container-org4b2e008" class="outline-2">
<h2 id="org4b2e008">Hello World</h2>
<div class="outline-text-2" id="text-org4b2e008">
<p>
You can just pass &ldquo;Hello World&rdquo; (with quotes) to the Lisp REPEL and you will get your first Hello World in Lisp.
</p>

<p>
This works because strings, like numbers, have a literal syntax that’s understood by the Lisp reader and are self-evaluating objects: Lisp reads the double-quoted string and instantiates a string object in memory that, when evaluated, evaluates to itself and is then printed in the same literal syntax. The quotation marks aren’t part of the string object in memory—they’re just the syntax that tells the reader to read a string. The printer puts them back on when it prints the string because it tries to print objects in the same syntax the reader understands.
</p>

<p>
However, this may not really qualify as a “hello, world” program. It’s more like the “hello, world” value.
</p>

<p>
You can take a step toward a real program by writing some code that as a side effect prints the string “hello, world” to standard output. Common Lisp provides a couple ways to emit output, but the most flexible is the <code>FORMAT</code> function. <code>FORMAT</code> takes a variable number of arguments, but the only two required arguments are the place to send the output and a string. You’ll see in the next chapter how the string can contain embedded directives that allow you to interpolate subsequent arguments into the string, à la printf or Python’s string-%. As long as the string doesn’t contain an \~, it will be emitted as-is. If you pass t as its first argument, it sends its output to standard output. So a <code>FORMAT</code> expression that will print “hello, world” looks like this:
</p>


<pre class="example" id="org289421e">
CL-USER&gt; (format t "hello, world")
hello, world
NIL
</pre>

<p>
However, it’s still arguable whether you’ve yet written a true “program.” But you’re getting there. And you’re seeing the bottom-up style of programming supported by the REPL: you can experiment with different approaches and build a solution from parts you’ve already tested.  Now that you have a simple expression that does what you want, you just need to package it in a function. Functions are one of the basic program building blocks in Lisp and can be defined with a <code>DEFUN</code> expression such as this:
</p>

<pre class="code"><code>CL-USER&gt; (<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">hello-world</span> () (format t <span style="color: #8a3b3c;">"hello, world"</span>))
HELLO-WORLD
</code></pre>

<p>
At one level, this expression, like all the others you’ve seen, is just another expression to be read, evaluated, and printed by the REPL. The return value in this case is the name of the function you just defined and we will discuss later why was it uppercased.
</p>
</div>
</div>
<div id="outline-container-nse0owp02wj0" class="outline-2">
<h2 id="nse0owp02wj0">Why Lisp?</h2>
<div class="outline-text-2" id="text-orgfbd7231">
<p>
Why learn Lisp? Because it lets you do things that you can&rsquo;t do in other languages. If you just wanted to write a function to return the sum of the numbers less than n&gt; say, it would look much the same in Lisp and C:
</p>

<pre class="code"><code>(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">sum</span> (n)
   (<span style="font-weight: bold;">let</span> ((s 0))
       (<span style="font-weight: bold;">dotimes</span> (i n s)
            (incf s i))))
</code></pre>

<pre class="code"><code><span style="font-weight: bold;">int</span> <span style="font-weight: bold;">aum</span>(<span style="font-weight: bold;">int</span> <span style="color: #383a42;">n</span>){
    <span style="font-weight: bold;">int</span> <span style="color: #383a42;">i</span> , <span style="color: #383a42;">s</span> = 0;
    <span style="font-weight: bold;">for</span> ( i = 0; i &lt; n; i++)
        s += i ;
    <span style="font-weight: bold;">return</span>(s);
}
</code></pre>

<p>
If you only need to do such simple things, it doesn&rsquo;t really matter which language you use. Suppose instead you want to write a function that takes a number n, and returns a function that adds n to its argument:
</p>
<pre class="code"><code>(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">addn</span> (n)
    #'(<span style="font-weight: bold;">lambda</span> (x)
     (+ x n)))
</code></pre>

<p>
What does addn look like in C? You just can&rsquo;t write it.  You might be wondering, when does one ever want to do things like this?  Programming languages teach you not to want what they cannot provide.  You have to think in a language to write programs in it, and it&rsquo;s hard to want something you can&rsquo;t describe. When I first started writing programs—in Basic—I didn&rsquo;t miss recursion, because I didn&rsquo;t know there was such a thing.  I thought in Basic. I could only conceive of iterative algorithms, so why should I miss recursion?
</p>

<p>
Lisp is designed to be extensible: it lets you define new operators yourself. This is possible because the Lisp language is made out of the same functions and macros as your own programs. So it&rsquo;s no more difficult to extend Lisp than to write a program in it. In fact, it&rsquo;s so easy (and so useful) that extending the language is standard practice. As you&rsquo;re writing your program down toward the language, you build the language up toward your program. You work bottom-up, as well as top-down.
</p>

<p>
As programming environments grow in power, and languages become more abstract, the Lisp style of programming is gradually replacing the old plan-and-implement model.
</p>

<p>
In the old model, bugs are never supposed to happen. Thorough specifications, painstakingly worked out in advance, are supposed to ensure that programs work perfectly. Sounds good in theory. Unfortunately, the specifications are both written and implemented by humans. The result, in practice, is that the plan-and-implement method does not work very well.
</p>

<p>
Planning is a necessary evil. It is a response to risk: the more dangerous an undertaking, the more important it is to plan ahead. Powerful tools decrease risk, and so decrease the need for planning. The design of your program can then benefit from what is probably the most useful source of information available: the experience of implementing it.
</p>

<p>
Lisp style has been evolving in this direction since the 1960s. You can write prototypes so quickly in Lisp that you can go through several iterations of design and implementation before you would, in the old model, have even finished writing out the specifications. You don&rsquo;t have to worry so much about design flaws, because you discover them a lot sooner. Nor do you have to worry so much about bugs. When you program in a functional style, bugs can only have a local effect. When you use a very abstract language, some bugs (e.g. dangling pointers) are no longer possible, and what remain are easy to find, because your programs are so much shorter. And when you have an interactive environment, you can correct bugs instantly, instead of enduring a long cycle of editing, compiling, and testing.
</p>


<p>
Lisp style has been evolving in this direction since the 1960s. You can write prototypes so quickly in Lisp that you can go through several iterations of design and implementation before you would, in the old model, have even finished writing out the specifications. You don&rsquo;t have to worry so much about design flaws, because you discover them a lot sooner. Nor do you have to worry so much about bugs. When you program in a functional style, bugs can only have a local effect. When you use a very abstract language, some bugs (e.g. dangling pointers) are no longer possible, and what remain are easy to find, because your programs are so much shorter. And when you have an interactive environment, you can correct bugs instantly, instead of enduring a long cycle of editing, compiling, and testing.
</p>
</div>
</div>
<div id="outline-container-org61f3e77" class="outline-2">
<h2 id="org61f3e77">Lisp Specifications</h2>
<div class="outline-text-2" id="text-org61f3e77">
<p>
&ldquo;Okay I&rsquo;m convinced&rdquo;
</p>
</div>
<div id="outline-container-org43521b8" class="outline-3">
<h3 id="org43521b8">Evaluation</h3>
<div class="outline-text-3" id="text-org43521b8">
<p>
In Lisp, + is a function, and an expression like (+ 2 3) is a function call. When Lisp evaluates a function call, it does so in two steps:
</p>

<ol class="org-ol">
<li>First the arguments are evaluated, from left to right. In this case, each argument evaluates to itself, so the values of the arguments are 2 and 3, respectively.</li>

<li>The values of the arguments are passed to the function named by the operator. In this case, it is the + function, which returns 5.</li>
</ol>


<p>
Not all the operators in Common Lisp are functions, but most are. And function calls are always evaluated this way. The arguments are evaluated left-to-right, and their values are passed to the function, which returns the value of the expression as a whole. This is called the evaluation rule for Common Lisp.
</p>


<p>
One operator that doesn&rsquo;t follow the Common Lisp evaluation rule is quote. The quote operator is a special operator, meaning that it has a distinct evaluation rule of its own. And the rule is: do nothing. The quote operator takes a single argument, and just returns it verbatim:
</p>

<pre class="code"><code>(<span style="font-weight: bold;">quote</span> (<span style="color: #383a42;">+</span> 4 5))
</code></pre>

<p>
For convenience, Common Lisp defines &rsquo; as an abbreviation for quote.  You can get the effect of calling quote by affixing a &rsquo; to the front of any expression:
</p>


<pre class="code"><code>`(+ 4 5)
</code></pre>

<p>
It is much more common to use the abbreviation than to write out the whole quote expression.
</p>

<p>
Lisp provides the quote as a way of protecting expressions from evaluation. The next section will explain how such protection can be useful.
</p>


<p>
Symbols do not (usually) evaluate to themselves, so if you want to refer to a symbol, you should quote it, as above.
</p>

<p>
Lists are represented as zero or more elements enclosed in parentheses.  The elements can be of any type, including lists. You have to quote lists, or Lisp would take them for function calls:
</p>
</div>
</div>
<div id="outline-container-org62fb4e2" class="outline-3">
<h3 id="org62fb4e2">Data</h3>
<div class="outline-text-3" id="text-org62fb4e2">
<p>
Lisp offers all the data types we find in most other languages, along with several others that we don&rsquo;t. One data type we have used already is the integer, which is written as a series of digits: 256. Another data type Lisp has in common with most other languages is the string, which is represented as a series of characters surrounded by double-quotes: &ldquo;ora et labora&rdquo;. Integers and strings both evaluate to themselves.
</p>

<p>
Lists are represented as zero or more elements enclosed in parentheses. The elements can be of any type, including lists. You have to quote lists, or Lisp would take them for function calls:
</p>


<pre class="code"><code>`(pray sunrise)
</code></pre>

<p>
Notice that one quote protects a whole expression, including expressions within it.  You can build lists by calling list. Since list is a function, its arguments are evaluated. Here we see a call to + within a call to list:
</p>

<pre class="code"><code>(list `my `(+ 2 3))
</code></pre>

<p>
We are now in a position to appreciate one of the most remarkable features of Lisp. Lisp programs are expressed as lists. If the arguments of flexibility and elegance did not convince you that Lisp notation is a valuable tool, this point should. It means that Lisp programs can generate Lisp code. Lisp programmers can (and often do) write programs to write their programs for them.
</p>
</div>
</div>
<div id="outline-container-orgd0c88f5" class="outline-3">
<h3 id="orgd0c88f5">List Operations</h3>
<div class="outline-text-3" id="text-orgd0c88f5">
<p>
The function cons builds lists. If its second argument is a list, it returns a new list with the first argument added to the front:
</p>

<pre class="code"><code>(cons ' a ' (b c d))
</code></pre>

<p>
We can build up lists by consing new elements onto an empty list. The list function that we saw in the previous section is just a more convenient way of consing several things onto <code>nil</code>.
</p>

<p>
The primitive functions for extracting the elements of lists are car and cdr. The car of a list is the first element, and the cdr is everything after the first element:
</p>

<pre class="code"><code>(car `(ab c))
</code></pre>

<pre class="code"><code>(cdr `(ab c))
</code></pre>


<p>
<i>The parentheses in the cdr are for that it is probably a list, since it is everything but the first element, but in car it is only a one element that&rsquo;s why there is not parentheses</i>.
</p>

<p>
You can use combinations of car and cdr to reach any element of a list. If you want to get the third element, you could say:
</p>

<pre class="code"><code>(car (cdr (cdr ' ( a b c d ) ) ) )
</code></pre>

<p>
However, you can do the same thing more easily by calling third :
</p>

<pre class="code"><code>( second '( a b c d))
</code></pre>

<p>
There are also <code>first</code> and <code>second</code>, you can guess what is their functionality.
</p>
</div>
</div>
<div id="outline-container-org718f275" class="outline-3">
<h3 id="org718f275">Truth</h3>
<div class="outline-text-3" id="text-org718f275">
<p>
In Common Lisp, the symbol t is the default representation for truth. Like
nil, t evaluates to itself. The function <code>listp</code> returns true if its argument is
a list:
</p>


<pre class="code"><code>(listp `(a b c))
</code></pre>

<p>
A function whose return value is intended to be interpreted as truth or falsity is called a predicate. Common Lisp predicates often have names that end with p.
</p>

<p>
The simplest conditional in Common Lisp is if. It usually takes three arguments: a test expression, a then expression, and an else expression. The test expression is evaluated. If it returns true, the then expression is evaluated and its value is returned. If the test expression returns false, the else expression is evaluated and its value is returned:
</p>

<pre class="code"><code>(<span style="font-weight: bold;">if</span> (listp '(abc))
    (+ 1 2)
    (+ 5 6))
</code></pre>

<p>
Like quote, if is a special operator. It could not possibly be implemented as a function, because the arguments in a function call are always evaluated, and the whole point of if is that only one of the last two arguments is evaluated.  The last argument to if is optional. If you omit it, it defaults to nil.
</p>

<p>
There are <code>and</code> and <code>or</code> functions, you probably can tell what do they do.
</p>
</div>
</div>
<div id="outline-container-orgd7c7db5" class="outline-3">
<h3 id="orgd7c7db5">Basic Functions</h3>
<div class="outline-text-3" id="text-orgd7c7db5">
<p>
You can define new functions with defun. It usually takes three or more
arguments: a name, a list of parameters, and one or more expressions that
will make up the body of the function. Here is how we might define third:
</p>

<pre class="code"><code>(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">our-third</span> (x)
    (car (cdr (cdr x ))))
</code></pre>

<p>
Let&rsquo;s try to defun <code>member</code> which tells you if whether an element is a member of
function:
</p>

<pre class="code"><code>(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">somemeeber</span> (obj lst)
  (<span style="font-weight: bold;">if</span> (null lst) nil
      (<span style="font-weight: bold;">if</span> (eql (car lst) obj) t
          (somemeeber obj (cdr lst)))))
</code></pre>


<p>
The difference between this implementation (along many other things in the
internal implementation) is that instead of evaluating the rest of the list the
that member does it, I evaluate the truth value t.
</p>

<pre class="code"><code>(somemeeber 3 '(1 2 3 4))
</code></pre>
</div>
</div>
<div id="outline-container-orgab71ef8" class="outline-3">
<h3 id="orgab71ef8">I/O</h3>
<div class="outline-text-3" id="text-orgab71ef8">
<p>
The most general output function in Common Lisp is f ormat. It takes two or more
arguments: the first indicates where the output is to be printed, the second is
a string template, and the remaining arguments are usually objects whose printed
representations are to be inserted into the template. Here is a typical example:
</p>
<pre class="code"><code>(format t <span style="color: #8a3b3c;">"~A plus ~A equals ~A. ~%"</span> 2 3 ( + 2 3))
</code></pre>

<p>
Notice that two things get displayed here. The first line is displayed by
format. The second line is the value returned by the call to format, displayed
in the usual way by the toplevel. Ordinarily a function like format is not
called directly from the toplevel, but used within programs, so the return
value is never seen.
</p>


<p>
The first argument to format, t, indicates that the output is to be sent to the
default place. Ordinarily this will be the toplevel. The second argument is a
string that serves as a template for output. Within this string, each ~A
indicates a position to be filled, and the ~% indicates a newline. The positions
are filled by the values of the remaining arguments, in order.
</p>


<p>
The standard function for input is read. When given no arguments, it
reads from the default place, which will usually be the toplevel. Here is a
function that prompts the user for input, and returns whatever is entered:
</p>

<pre class="code"><code>(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">askem</span> (string)
  (format t <span style="color: #8a3b3c;">""</span>A<span style="color: #8a3b3c;">" string)
    (read))</span>
</code></pre>
</div>
</div>
<div id="outline-container-org613c802" class="outline-3">
<h3 id="org613c802">Variables</h3>
<div class="outline-text-3" id="text-org613c802">
<p>
One of the most frequently used operators in Common Lisp is <code>let</code> , which
allows you to introduce new local variables.
</p>


<p>
A <code>let</code> expression has two parts. First comes a list of instructions for
creating variables, each of the form (variable expression). Each variable will
initially be set to the value of the corresponding expression.
</p>

<pre class="code"><code>(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">ask-for-number</span> ()
  (format t <span style="color: #8a3b3c;">"Enter a number"</span>)
  (<span style="font-weight: bold;">let</span> ((n (read)))
    (<span style="font-weight: bold;">if</span> (numberp n)
        n
        (ask-for-number))))
</code></pre>

<p>
You can create a global variable by giving a symbol and a value to
<code>defparameter</code>:
</p>

<p>
Such a variable will then be accessible everywhere, except in expressions that
create a new local variable with the same name. To avoid the possibility of
this happening by accident, it&rsquo;s conventional to give global variables names
that begin and end with asterisks. The name of the variable we just created
would be pronounced &ldquo;star-glob-star&rdquo;.
</p>

<p>
You can also define global constants, by calling def constant:
</p>

<pre class="code"><code>(<span style="font-weight: bold;">defconstant</span> <span style="color: #383a42;">limit</span> (+ *glob* 1))
</code></pre>


<p>
There is no&rsquo;need to give constants distinctive names, because it will cause
an error if anyone uses the same name for a variable. If you want to check
whether some symbol is the name of a global variable or constant, use boundp:
</p>

<pre class="code"><code>(<span style="font-weight: bold;">defconstant</span> <span style="color: #383a42;">*glob*</span> 43)
(boundp '*glob*)
</code></pre>
</div>
</div>
<div id="outline-container-org53ee9f5" class="outline-3">
<h3 id="org53ee9f5">Assignment</h3>
<div class="outline-text-3" id="text-org53ee9f5">
<p>
In Common Lisp the most general assignment operator is setf. We can use
it to do assignments to either kind of variable:
</p>
<pre class="code"><code>(setf *glob* 90)
</code></pre>


<pre class="code"><code>(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">read-number-and-prefix-with-message</span> ()
  (<span style="font-weight: bold;">let</span> ((n (ask-for-number)))
    (setf n (+ n 1))
    (format t <span style="color: #8a3b3c;">"The new number is ~A"</span> n)))
</code></pre>
</div>
</div>
<div id="outline-container-orgb8b1292" class="outline-3">
<h3 id="orgb8b1292">Iteration</h3>
<div class="outline-text-3" id="text-orgb8b1292">
<p>
When we want to do something repeatedly, it is sometimes more natural to
use iteration than recursion. A typical case for iteration is to generate some
sort of table. This function
</p>

<pre class="code"><code>(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">show-squares</span> (start end)
  (<span style="font-weight: bold;">do</span> ((i start (+ i 1)))
      ((&gt; i end) 'done)
    (format t <span style="color: #8a3b3c;">"~A ~A~%"</span> i (* i i))))
(show-squares 2 4)
</code></pre>

<p>
The <code>do</code> macro is the fundamental iteration operator in Common Lisp.  Like <code>let</code> ,
do can create variables, and the first argument is a list of variable
specifications. Each element of this list can be of the form
</p>

<pre class="example" id="orgfb2cbba">
{variable initial update)
</pre>

<p>
where variable is a symbol, and initial and update are expressions. Initially
each variable will be set to the value of the corresponding initial, on each
iteration it will be set to the value of the corresponding update. The do in
show-squares creates just one variable, i . On the first iteration i will be set
to the value of <code>start</code> , and on successive iterations its value will be
incremented by one.
</p>


<p>
The remaining arguments to do comprise the body of the loop. They will be
evaluated, in order, on each iteration. On each iteration the variables are
updated, then the termination test is evaluated, and then (if the test failed)
the body is evaluated.
</p>



<pre class="code"><code>(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">show-squares</span> (i end)
 (<span style="font-weight: bold;">if</span> (&gt; i end)
  'done
  (<span style="font-weight: bold;">progn</span>
     (format t M~A ~A~&#176;/,n i (* i i ) )
   (show-squares (+ i 1) e n d))))
</code></pre>


<p>
Common Lisp has simpler iteration operators for special cases. To iterate
through the elements of a list, for example, you would be more likely to use
<code>dolist</code> . Observe the following functions:
</p>

<pre class="code"><code>(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">our-length-without-do</span> (lst)
  (<span style="font-weight: bold;">if</span> (null lst)
      0
      (+ (our-length-without-do (cdr lst)) 1)))
</code></pre>
</div>
</div>
<div id="outline-container-org58a7543" class="outline-3">
<h3 id="org58a7543">Functions as Objects</h3>
<div class="outline-text-3" id="text-org58a7543">
<p>
In Lisp, functions are regular objects, like symbols or strings or lists. If we
give the name of a function to function, it will return the associated object.
Like quote, function is a special operator, so we don&rsquo;t have to quote the
argument:
</p>

<pre class="code"><code>(function +)
</code></pre>

<p>
You can replace the <code>+</code> with any other operator or function like <code>read</code>.
</p>

<p>
This strange-looking return value is the way a function might be displayed in a
typical Common Lisp implementation.
</p>

<p>
Until now we have only dealt with objects that look the same when Lisp displays
them as when we typed them in. This convention does not apply to functions.
Internally, a built-in function like + is likely to be a segment of machine
language code. A Common Lisp implementation may choose whatever external
representation it likes.
</p>

<p>
Just as we can use <code>'</code> as an abbreviation for quote, we can use <code>#'</code> as an
abbreviation for function:
</p>

<pre class="example" id="org0541183">
(apply #'+ l) ==  (apply (function +) l)
</pre>

<p>
<code>#'</code> (aka function) can be used in front of (<code>lambda</code> &#x2026;) (we will talk about
lambda soon) but it&rsquo;s redundant there, so the only place where it&rsquo;s really
meaningful is in front of a symbol, as in <code>#'car</code>. In ELisp, <code>#'car</code> and <code>'car</code>
are almost completely equivalent, so one of the main purpose is simply to
document the intention (i.e. to indicate to whoever reads this code that you
intend to use this symbol as a function). Yet there are a few circumstances,
where the difference is more significant:
</p>

<ul class="org-ul">
<li>The byte-compiler takes advantage of this documented intention and when you
write <code>#'car</code> it will check whether car exists as a function, and if it doesn&rsquo;t
find it, it will emit a warning, just like it would if you had a call to that
function.</li>
<li><p>
Inside <code>cl-flet</code> and <code>cl-labels</code>, only <code>#'f</code> can refer to the locally defined
function <code>f</code>, because <code>'f</code> will still refer to the global symbol <code>f</code> (and
whichever function might be stored in its symbol-function slot). E.g.
</p>

<pre class="example" id="org98e297d">
(cl-flet ((car (x y) (+ x y)))
  (list #'car 'car))
=&gt;
((closure nil (x y) (+ x y)) car)
</pre>

<p>
(<a href="https://endlessparentheses.com/get-in-the-habit-of-using-sharp-quote.html">read: Get in the habit of using sharp quote</a>)
</p></li>
</ul>

<p>
Like any other kind of object, we can pass functions as arguments. One function
that takes a function as an argument is apply. It takes a function and a list of
arguments for it, and returns the result of applying the function to the
arguments:
</p>

<pre class="code"><code>(apply #'+ ' ( 1 2 3))
</code></pre>


<p>
The function f u n c a l l does the same thing but does not need the arguments
to be packaged in a list:
</p>

<pre class="code"><code>(funcall #'+ 1 2 3)
</code></pre>

<p>
The <code>defun</code> macro creates a function and gives it a name. But functions don&rsquo;t
have to have names, and we don&rsquo;t need def un to define them. Like most other
kinds of Lisp objects, we can refer to functions literally.
</p>

<p>
To refer literally to an integer, we use a series of digits; to refer literally
to a function, we use what&rsquo;s called a lambda expression. A lambda expression is
a list containing the symbol lambda, followed by a list of parameters, followed
by a body of zero or more expressions.
</p>


<p>
Here is a lambda expression representing a function that takes two numbers and
returns their sum:
</p>

<pre class="code"><code>(<span style="font-weight: bold;">lambda</span> (x y)
  (+ x y))
</code></pre>

<p>
A lambda expression can be considered as the name of a function. Like an
ordinary function name, a lambda expression can be the first element of a
function call, for example:
</p>

<pre class="code"><code>((<span style="font-weight: bold;">lambda</span> (x) (+ x 100)) 2)
</code></pre>
</div>
</div>
<div id="outline-container-orgb22e559" class="outline-3">
<h3 id="orgb22e559">Types</h3>
<div class="outline-text-3" id="text-orgb22e559">
<p>
Lisp has an unusually flexible approach to types. In many languages, variables
are what have types, and you can&rsquo;t use a variable without specifying its type.
In Common Lisp, values have types, not variables. You could imagine that every
object had a label attached to it, identifying its type. This approach is called
manifest typing. You don&rsquo;t have to declare the types of variables, because any
variable can hold objects of any type.
</p>

<p>
(read more about <a href="https://wiki.c2.com/?ManifestTyping">manifest typing</a>)
</p>

<p>
We will study types in details later.
</p>
</div>
</div>
</div>
<div id="outline-container-orgcc40424" class="outline-2">
<h2 id="orgcc40424">Lists</h2>
<div class="outline-text-2" id="text-orgcc40424">
<p>
In Lisp, lists are one of the fundamental data structures in Lisp. In the
earliest dialects they were the only data structure: the name &ldquo;Lisp&rdquo; originally
stood for &ldquo;LISt Processor.&rdquo; But Lisp has long since outgrown this acronym.
Common Lisp is a general-purpose programming language with a wide variety of
data structures.
</p>
</div>
<div id="outline-container-org0afd80a" class="outline-3">
<h3 id="org0afd80a">Conses</h3>
<div class="outline-text-3" id="text-org0afd80a">
<p>
We previously introduced <code>cons</code>, <code>car</code>, and <code>cdr</code>, the primitive list
manipulation functions, what cons really does is combine two objects into a
two-part objects into a two-part object called <code>cons</code>.  Conceptually, a cons is
a pair of pointers; the first one is the car and the second is the <code>cdr</code>.
</p>



<p>
Conses provide a convenient representation for pairs of any type. The two halves
of a cons can point to any kind of object, including conses. It is by taking
advantage of the latter possibility that we use conses to build lists.  One does
not tend to think of lists as pairs, but they can be defined that way. Any
nonempty list can be considered as a pair of the first element and the rest of
the list.
</p>

<p>
Lisp lists are the embodiment of this idea. We use one half of the cons to point
to the first element of the list, and the other to point to the rest of the list
(which is either another cons or <code>nil</code>). The convention in Lisp has always been
to use the car for the first element and the cdr for the rest of the list. So
now car is synonymous with the first element of a list, and cdr with the rest.
Lists are not a distinct kind of object, but conses linked together in this way.
</p>


<p>
The last two lists we made both have three elements; it just happens that the
second element of z is also a list. Such a list is called a nested list, while a
list like y that doesn&rsquo;t contain other lists as elements is called a flat list.
</p>

<p>
The function <code>consp</code> returns true if its argument is a cons. So l i s t p could
be defined:
</p>

<pre class="code"><code>(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">our-listp</span> (x)
   (or (null x) (consp x)))
</code></pre>


<p>
Since everything that is not a cons is an atom, the predicate atom could be
defined:
</p>

<pre class="code"><code>(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">our-atom</span> (x) (not (consp x )))
</code></pre>
</div>
<div id="outline-container-orgcf86aa3" class="outline-4">
<h4 id="orgcf86aa3">Equality</h4>
<div class="outline-text-4" id="text-orgcf86aa3">
<p>
Each time you call cons, Lisp allocates a new piece of memory with room
for two pointers. So if we call cons twice with the same arguments, we get
back two values that look the same, but are in fact distinct objects:
</p>

<pre class="code"><code>(eql (cons 'a nil) (cons 'a nil) )
</code></pre>

<p>
<code>equal</code>, essentially, returns true if its arguments would print the same:
</p>

<pre class="code"><code>(equal (cons 'a nil) (cons 'a nil) )
</code></pre>
</div>
</div>
<div id="outline-container-org69dd7e9" class="outline-4">
<h4 id="org69dd7e9">Pointers</h4>
<div class="outline-text-4" id="text-org69dd7e9">
<p>
One of the secrets to understanding Lisp is to realize that variables have
values in the same way that lists have elements. As conses have pointers to
their elements, variables have pointers to their values.
</p>

<p>
You may have used other languages in which pointers were manipulated explicitly.
In Lisp you never have to do this, because the language handles pointers for
you. We&rsquo;ve already seen how this happens with lists. Something
</p>

<p>
similar happens with variables. Suppose, for example, we set two variables to
the same list:
</p>

<pre class="code"><code>(setf y (list 'a 'b 'c))
(setf x '( a b c))
</code></pre>

<p>
What actually happens when we set y to the value of x? The location in
memory associated with the variable x does not contain the list itself, but a
pointer to it. When we assign the same value to y, Lisp copies the pointer, not
the list. So whenever you assign
one variable the value of another, the two variables will have e q l values:
</p>

<pre class="code"><code>(setf y (list 'a 'b 'c))
(setf x '( a b c))
(setf y x)
(eql x y)
</code></pre>
</div>
</div>
</div>
<div id="outline-container-orgb7e7c2c" class="outline-3">
<h3 id="orgb7e7c2c">Example: Compression</h3>
<div class="outline-text-3" id="text-orgb7e7c2c">
<p>
As an example, this section shows how to perform a simple form of compression on
lists. This algorithm goes by the impressive name of <code>run-length</code>, it should
work as follows:
</p>

<pre class="code"><code>(comprs '(a a a c))
</code></pre>


<pre class="code"><code>(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">comprs</span> (x)
  (ucompr (car x) 1 (cdr x)))


(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">ucompr</span> (elmnt n lst)
  (<span style="font-weight: bold;">if</span> (null lst)
      (list (build elmnt n))
      (<span style="font-weight: bold;">let</span> ((next (car lst)))
        (<span style="font-weight: bold;">if</span> (eql next elmnt)
            (ucompr elmnt (+ n 1) (cdr lst))
            (cons (build elmnt n) (ucompr next 1 (cdr lst)))))))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">build</span> (elmnt n)
  (<span style="font-weight: bold;">if</span> (&gt; n 1)
      (list n elmnt)
      elmnt))
</code></pre>



<p>
Can you write one to do uncompress?
</p>


<pre class="code"><code>(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">unbuild</span> (n elmt)
  (<span style="font-weight: bold;">if</span> (zerop n)
      nil
      (cons elmt (unbuild (- n 1) elmt))))

(<span style="font-weight: bold;">defun</span> <span style="font-weight: bold;">uncompress</span> (lst)
  (<span style="font-weight: bold;">if</span> (null lst)
      nil
      (<span style="font-weight: bold;">if</span> (listp (car lst))
          (<span style="font-weight: bold;">let</span> ((f (car (car lst)))
                (s (cdr (car lst))))
            (cons (unbuild f s)
                  (uncompress (cdr lst))))
          (uncompress (cdr lst)))))
</code></pre>


<p>
This will work, however, as you will see we are going to get some different kind
of lists, lists of lists;
</p>

<pre class="code"><code>(uncompress (list '(3 A) '(3 B) '(2 C)))
</code></pre>
</div>
</div>
<div id="outline-container-orga7733d7" class="outline-3">
<h3 id="orga7733d7">Access</h3>
<div class="outline-text-3" id="text-orga7733d7">
<p>
Common Lisp has additional access functions defined in terms of <code>car</code> and
<code>cdr</code>. To find the element at a given position in a list we call <code>nth</code>,
</p>

<pre class="code"><code>(nth 0 ' ( a b c))
</code></pre>

<p>
and to find the nth cdr, we call <code>nthcdr</code>:
</p>

<pre class="code"><code>(nthcdr 2 ' ( a b c))
</code></pre>


<p>
Both <code>nth</code> and <code>nthcdr</code> are zero-indexed; that is, the elements are numbered
starting at zero rather than one. In Common Lisp, whenever you use a number
to refer to an element of a data structure, the numbering starts at zero.
The two functions do almost the same thing; <code>nth</code> is equivalent to car of
nthcdr.
</p>
</div>
</div>
<div id="outline-container-orgb020941" class="outline-3">
<h3 id="orgb020941">Mapping functions</h3>
<div class="outline-text-3" id="text-orgb020941">
<p>
Common Lisp provides several functions for calling functions on the elements
of a list. The most frequently used is mapcar, which takes a function and
one or more lists, and returns the result of applying the function to elements
taken from each list, until some list runs out:
</p>

<pre class="code"><code>(mapcar #'(<span style="font-weight: bold;">lambda</span> (x) (+ x 10))
         '(1 2 3))
</code></pre>

<p>
The related <code>maplist</code> takes the same arguments, but calls the function on
successive <code>cdrs</code> of the lists:
</p>

<pre class="code"><code>(maplist #'(<span style="font-weight: bold;">lambda</span> (x) x)
          '(a b c))
</code></pre>
</div>
</div>
<div id="outline-container-org82c37a0" class="outline-3">
<h3 id="org82c37a0">Trees</h3>
<div class="outline-text-3" id="text-org82c37a0">
<p>
Conses can also be considered as binary trees, with the car representing the
right subtree and the cdr the left. For example, the list
</p>
<pre class="example" id="org58609f2">
(a (b c) d)
</pre>

<p>
is also the tree represented in the following figure:
</p>


<figure id="org451eb74">
<img src="../i/old/2023-03-05_17-47.png" alt="2023-03-05_17-47.png">

</figure>

<p>
Binary trees without interior nodes are not useful for much. Common Lisp
includes functions for operating on trees not because one needs trees as such,
but because one needs a way to do something to a list and all the lists within
it. For example, suppose we have a list like
</p>

<pre class="code"><code>(and (integerp x) (zerop (mod x 2)))
</code></pre>

<p>
and we want to substitute y for x throughout. It won&rsquo;t do to call substitute,
which replaces elements in a sequence:
</p>
<pre class="code"><code>(substitute 'y 'x '(and (integerp x) (zerop (mod x 2))))
</code></pre>

<p>
As you can see, this call is ineffective because <code>substitute</code> looks for
sequential elements, like this:
</p>


<pre class="code"><code>(substitute 'y 'x '(x (integerp x) (zerop (mod x 2))))
</code></pre>
<p>
However, there is a good replacement which is <code>subset</code>, which can access
subtrees:
</p>


<pre class="code"><code>(subst 'y 'x '(and (integerp x) (zerop (mod x 2))))
</code></pre>
<p>
(AND (INTEGERP Y) (ZEROP (MOD Y 2)))
</p>
</div>
</div>
<div id="outline-container-org84c3eee" class="outline-3">
<h3 id="org84c3eee">Sequences</h3>
<div class="outline-text-3" id="text-org84c3eee">
<p>
Another way to think of a list is as a series of objects in a particular order.
In Common Lisp, sequences include both lists and vectors.
</p>

<p>
To copy part of a sequence, we use <code>subseq</code>. The second argument (required) is
the position of the first element to be included, and the third argument
(optional) is the position of the first element not to be included.
</p>

<p>
The function <code>reverse</code> returns a sequence with the same elements as its
argument, but in the reverse order:
</p>

<pre class="code"><code>(reverse '(a b c))
</code></pre>

<p>
Common Lisp has a built-in sort function called <code>sort</code>. It takes a sequence and
a comparison function of two arguments, and returns a sequence with the same
elements, sorted according to the function:
</p>


<pre class="code"><code>(sort '( 0 2 1 3 8 ) #'&gt;)
</code></pre>

<p>
You have to be careful when using <code>sort</code> , because it&rsquo;s destructive. For
efficiency reasons, <code>sort</code> is allowed to modify the sequence given to it as an
argument. So if you don&rsquo;t want your original sequence modified, pass a copy.
</p>
</div>
</div>
<div id="outline-container-org9611c9c" class="outline-3">
<h3 id="org9611c9c">Dotted Pair Notation</h3>
<div class="outline-text-3" id="text-org9611c9c">
<p>
Dotted pair notation is a general syntax for cons cells that represents the CAR
and CDR explicitly. In this syntax, <code>(a . b)</code> stands for a cons cell whose CAR
is the object a and whose CDR is the object b. Dotted pair notation is more
general than list syntax because the CDR does not have to be a list. However, it
is more cumbersome in cases where list syntax would work. In dotted pair
notation, the list <code>(1 2 3)</code> is written as <code>(1 . (2 . (3 . nil)))</code>. For
nil-terminated lists, you can use either notation, but list notation is usually
clearer and more convenient. When printing a list, the dotted pair notation is
only used if the CDR of a cons cell is not a list.
</p>
</div>
</div>
<div id="outline-container-orgd36ac61" class="outline-3">
<h3 id="orgd36ac61"><span class="done KILL">KILL</span> Example: Shortest Path&#xa0;&#xa0;&#xa0;<span class="tag"><span class="_write">@write</span></span></h3>
<div class="outline-text-3" id="text-orgd36ac61">
<p>
Following code contains a program for finding the shortest path through a
network.  The function <code>shortest-path</code> takes a start node, a destination node,
and a network, and returns the shortest path, if there is one.
</p>


<p>
In this example, nodes are represented as symbols, and networks are represented
as assoc-lists with elements of the form
</p>

<pre class="code"><code>(node . neighbors)
</code></pre>

<p>
For example:
</p>
<pre class="code"><code>(setf min '((a b c) (b c) (c d)))
</code></pre>

<p>
We can visualize it like this:
</p>


<figure id="orgb2000f8">
<img src="../i/old/Oa3OgZT.png" alt="Oa3OgZT.png">

</figure>
</div>
</div>
<div id="outline-container-orge841b18" class="outline-3">
<h3 id="orge841b18">Garbage</h3>
<div class="outline-text-3" id="text-orge841b18">
<p>
Lists can be slow for several reasons. They offer sequential instead of random
access, so retrieving a given element takes longer in a list than an array, for
the same reason that it takes longer to find something on a tape than on a disk.
Internally, conses tend to be represented as pointers, so traversing a list
means traversing a series of pointers, instead of simply incrementing an index,
as in an array. But these two costs can be small compared to the cost of
allocating and recycling cons cells.
</p>

<p>
Automatic memory management is one of Lisp&rsquo;s most valuable features.  The Lisp
system maintains a segment of memory called the heap. The system keeps track of
unused memory in the heap and doles it out as new objects are created. The
function cons, for example, returns a newly allocated cons.
</p>

<p>
Allocating memory from the heap is sometimes generically known as consing.  If
such memory were never freed, Lisp would run out of space for new objects and
have to shut down. So the system must periodically search through the heap,
looking for memory that is no longer needed. Memory that is no longer needed is
called garbage, and the scavenging operation is called garbage collection, or
GC.
</p>

<pre class="example" id="org756f212">
&gt; (setf 1st (list 'a &gt;b }c))
(A B C)
&gt; (setf 1st nil)
NIL
</pre>


<p>
Since we have no way of reaching this list, it might as well not exist.
Objects that we no longer have any way of reaching are garbage. The system
can safely reuse these three cons cells.
</p>

<p>
This way of managing memory is a great convenience to the programmer.
You never have to allocate or deallocate memory explicitly. And this means
that you never have to deal with the bugs that come from doing so. Memory
</p>


<p>
leaks and dangling pointers are simply impossible in Lisp.
</p>
</div>
</div>
</div>
<div id="outline-container-org0eb4242" class="outline-2">
<h2 id="org0eb4242">Data Structure</h2>
<div class="outline-text-2" id="text-org0eb4242">
<p>
The preceding discussed the list, Lisp&rsquo;s most versatile data structure.  This
chapter shows how to use Lisp&rsquo;s other data structures: arrays (including vectors
and strings), structures, and hash tables. They may not be as flexible as lists,
but they can make access faster, and take up less space.
</p>
</div>
<div id="outline-container-orgac377b6" class="outline-3">
<h3 id="orgac377b6">Arrays</h3>
<div class="outline-text-3" id="text-orgac377b6">
<p>
In Common Lisp, you can make an array by calling make-array with a list
of dimensions as the first argument. To make a 2x3 array we would say:
</p>
<pre class="code"><code>(make-array '(2 3))
</code></pre>
<p>
The <code>n</code> before the A tells how many dimensions the array have. You can also pass
a tag <code>initial-element</code> to set its value:
</p>

<pre class="code"><code>(make-array '(2 3) <span style="font-weight: bold;">:initial-element</span> 2)
</code></pre>

<p>
We can access both vectors and arrays using <code>aref</code>:
</p>

<pre class="code"><code>(aref (make-array '(2 3) <span style="font-weight: bold;">:initial-element</span> 2) 0 0)
</code></pre>

<p>
However, in the cause of vectors there is a fastere function which is <code>svref</code>
</p>

<pre class="code"><code>(svref (vector 'a 'b 'c) 2)
</code></pre>
</div>
</div>
<div id="outline-container-org59282f9" class="outline-3">
<h3 id="org59282f9"><span class="done KILL">KILL</span> Structures&#xa0;&#xa0;&#xa0;<span class="tag"><span class="_write">@write</span></span></h3>
</div>
</div>
<div id="outline-container-org2b36e5b" class="outline-2">
<h2 id="org2b36e5b">Functions</h2>
<div class="outline-text-2" id="text-org2b36e5b">
<p>
Understanding functions is one of the keys to understanding Lisp. Conceptually,
functions are at the core of Lisp. Practically, they are one of the most useful
tools at your disposal
</p>


<p>
The predicate f boundp tells whether there is a function with a given symbol as
its name. If a symbol is the name of a function, symbol-function will return it:
</p>

<pre class="code"><code>(fboundp '+)
</code></pre>

<p>
By setting the symbol-function of some name to a function,
</p>

<pre class="code"><code>(setf (symbol-function 'add2) #'(<span style="font-weight: bold;">lambda</span> (x) (+ x 2)))
</code></pre>

<pre class="code"><code>(add2 3)
</code></pre>
</div>
<div id="outline-container-org6475c20" class="outline-3">
<h3 id="org6475c20">Tags</h3>
<div class="outline-text-3" id="text-org6475c20">
<p>
We&rsquo;ve already seen four functions for retrieving elements of sequences:
nth for lists, aref and svref for vectors, and char for strings. Common
Lisp also provides a function <code>elt</code> that works for sequences of any kind:
</p>

<pre class="code"><code>(elt '(a b c) 1)
</code></pre>

<p>
Many sequence functions take one or more keyword arguments from the
standard set listed in this table:
</p>


<table>


<colgroup>
<col  class="org-left">

<col  class="org-left">

<col  class="org-left">
</colgroup>
<tbody>
<tr>
<td class="org-left">Paramater</td>
<td class="org-left">Purpose</td>
<td class="org-left"><code>DEAFULT</code></td>
</tr>

<tr>
<td class="org-left"><code>:key</code></td>
<td class="org-left">a function to apply to all elements</td>
<td class="org-left"><code>identity</code></td>
</tr>

<tr>
<td class="org-left"><code>:test</code></td>
<td class="org-left">the test function for comparison</td>
<td class="org-left"><code>eql</code></td>
</tr>

<tr>
<td class="org-left"><code>:from-end</code></td>
<td class="org-left">if true, work backwards</td>
<td class="org-left"><code>nil</code></td>
</tr>

<tr>
<td class="org-left"><code>:start</code></td>
<td class="org-left">position at which start</td>
<td class="org-left"><code>0</code></td>
</tr>

<tr>
<td class="org-left"><code>:end</code></td>
<td class="org-left">position, if any, at which to stop</td>
<td class="org-left"><code>nil</code></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-orgacbb538" class="outline-2">
<h2 id="orgacbb538">Functional Programming</h2>
<div class="outline-text-2" id="text-orgacbb538">
<p>
Functional programming means writing programs that work by returning values,
instead of by modifying things. It is the dominant paradigm in Lisp.  Most
built-in Lisp functions are meant to be called for the values they return, not
for side-effects.
</p>

<p>
The function remove, for example, takes an object and a list and returns
a new list containing everything but that object:
</p>

<p>
Why not just say that remove removes an object from a list? Because that&rsquo;s not
what it does. The original list is untouched afterwards:
</p>

<pre class="code"><code>(setf 1st ' (c a r a t ) )
(remove 'a 1st)
</code></pre>

<p>
Why not just say that remove removes an object from a list? Because that&rsquo;s
not what it does. The original list is untouched afterwards.
</p>
<pre class="code"><code>1st
</code></pre>

<p>
So what if you really do want to remove something from a list? In Lisp you
generally do such things by passing the list as an argument to some function,
and using setf with the return value. To remove all the as from a list x, we
say:
</p>

<pre class="code"><code>(setf x (remove 'a x))
</code></pre>

<p>
Functional programming means, essentially, avoiding setf and things
like it. At first sight it may be difficult to imagine how this is even possible,
let alone desirable. How can one build programs just by returning values?
</p>

<p>
It would be inconvenient to do without side-effects entirely. However, as
you read further, you may be surprised to discover how few you really need.
And the more side-effects you do without, the better off you&rsquo;ll be.
</p>



<p>
One of the most important advantages of functional programming is that it allows
interactive testing. In purely functional code, you can test each function as
you write it. If it returns the values you expect, you can be confident that it
is correct. The added confidence, in the aggregate, makes a huge difference. You
have instant turnaround when you make changes anywhere in a program. And this
instant turnaround enables a whole new style of programming, much as the
telephone, as compared to letters, enabled a new style of communication.
</p>
</div>
</div>
<div id="outline-container-orgfcccc56" class="outline-2">
<h2 id="orgfcccc56">Some Other Resources</h2>
<div class="outline-text-2" id="text-orgfcccc56">
<ul class="org-ul">
<li><a href="https://www.reddit.com/r/lisp/comments/tna6zo/moving_from_the_beam_to_common_lisp_what_are_my/i21hjef/">Concurrncy</a></li>
</ul>
</div>
</div>
<div id="outline-container-org6150210" class="outline-2">
<h2 id="org6150210"><span class="todo TODO">TODO</span> Ray-Tracing</h2>
</div>
<div id="outline-container-orge59f8e7" class="outline-2">
<h2 id="orge59f8e7">Misc: <code>eqal?</code></h2>
<div class="outline-text-2" id="text-orge59f8e7">
<ul class="org-ul">
<li><p>
<code>(eq x y)</code> is true if and only if x and y are the same identical object.
</p>
<pre class="example" id="orgd2cd32f">
(eq 'a 'b) is false.
(eq 'a 'a) is true.
(eq 3 3) might be true or false, depending on the implementation.
(eq 3 3.0) is false.
(eq 3.0 3.0) might be true or false, depending on the implementation.
(eq #c(3 -4) #c(3 -4))
  might be true or false, depending on the implementation.
(eq #c(3 -4.0) #c(3 -4)) is false.
(eq (cons 'a 'b) (cons 'a 'c)) is false.
(eq (cons 'a 'b) (cons 'a 'b)) is false.
(eq '(a . b) '(a . b)) might be true or false.
(progn (setq x (cons 'a 'b)) (eq x x)) is true.
(progn (setq x '(a . b)) (eq x x)) is true.
(eq #\A #\A) might be true or false, depending on the implementation.
(eq "Foo" "Foo") might be true or false.
(eq "Foo" (copy-seq "Foo")) is false.
(eq "FOO" "foo") is false.

</pre></li>

<li><p>
The <code>eql</code> predicate is true if its arguments are <code>eq</code>, or if they are numbers
of the same type with the same value, or if they are character objects that
represent the same character.
</p>
<pre class="example" id="orga5bf888">
(eql 'a 'b) is false.
(eql 'a 'a) is true.
(eql 3 3) is true.
(eql 3 3.0) is false.
(eql 3.0 3.0) is true.
(eql #c(3 -4) #c(3 -4)) is true.
(eql #c(3 -4.0) #c(3 -4)) is false.
(eql (cons 'a 'b) (cons 'a 'c)) is false.
(eql (cons 'a 'b) (cons 'a 'b)) is false.
(eql '(a . b) '(a . b)) might be true or false.
(progn (setq x (cons 'a 'b)) (eql x x)) is true.
(progn (setq x '(a . b)) (eql x x)) is true.
(eql #\A #\A) is true.
(eql "Foo" "Foo") might be true or false.
(eql "Foo" (copy-seq "Foo")) is false.
(eql "FOO" "foo") is false.
</pre></li>

<li>The <code>equal</code> predicate is true if its arguments are structurally similar
(isomorphic) objects. A rough rule of thumb is that two objects are equal if
and only if their printed representations are the same.</li>
</ul>
</div>
<div id="outline-container-yt" class="outline-3">
<h3 id="yt"><a href="../yt.html#6ed1b62f-0992-46dc-aefd-40c471ae0b66">YouTube Channels</a></h3>
<div class="outline-text-3" id="text-yt">
<ul class="org-ul">
<li><a href="https://www.youtube.com/@joshbetts1022">Josh Betts</a></li>
<li><a href="https://www.youtube.com/@GavinFreeborn">Gavin Freeborn</a></li>
<li><a href="https://www.youtube.com/@CBaggers">Baggers </a></li>
<li><a href="https://www.youtube.com/@CodeNextDoor">CodeNextDoor</a></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<div id="postamble" class="status">
<hr style="
    clear: both;
">

  <div class="book-covers" style="margin: 1em 0; padding: 0 10px;">
    <p style="margin: 0.5em 0; font-style: italic; color: #555;">Some works I recommend engaging with:</p>
    <div id="books-container" style="display: flex; flex-wrap: wrap; gap: 8px; max-width: 100%;"></div>
  </div>


  <script>
    const path = window.location.pathname;
    if (path !== '/' && path !== '/index.html') {
      const allBooks = [
        {title: 'The Computational Beauty of Nature', author: 'Gary William Flake'},
        {title: 'Group Psychology', author: 'Sigmund Freud'},
        {title: 'Logic', author: 'Nicholas Smith'},
        {title: 'Structure and Interpretation of Computer Programs', author: 'Harold Abelson'},
        {title: 'The C Programming Language', author: 'Brian Kernighan'},
        {title: 'Out of Bounds: Academic Freedom and the Question of Palestine', author: 'M. Abraham'},
        {title: 'Understanding Power: The Indispensable Chomsky', author: 'Noam Chomsky'},
        {title: 'Who Rules the World?', author: 'Noam Chomsky'},
        {title: 'Manufacturing Consent: The Political Economy of the Mass Media', author: 'Noam Chomsky'},
        {title: 'A People History of The World', author: 'Chris Harman'},
        {title: 'The Arabs: A History', author: 'Eugene Rogan'},
        {title: 'State of Terror', author: 'Y. Suarez'},
        {title: 'A People History of The United States', author: 'Howard Zinn'},
        {title: 'Killing Hope', author: 'William Blum'},
        {title: 'Deliverance From Error', author: 'Al-Ghazali'},
        {title: 'The Dawn of The Day', author: 'Friedrich Nietzsche'},
        {title: 'Islam and The Destiny of Man', author: 'Gai Eaton'},
        {title: 'The Polymath', author: 'Waqas Ahmed'},
        {title: 'Twilight of The Idols', author: 'Friedrich Nietzsche'},
        {title: 'Manfred', author: 'Lord Byron'},
        {title: 'Marx in Soho', author: 'Howard Zinn'}
      ];

      const shuffled = allBooks.sort(() => 0.5 - Math.random());
      const container = document.getElementById('books-container');
      let displayedBooks = 0;
      let bookIndex = 0;

      async function tryNextBook() {
        if (displayedBooks >= 2 || bookIndex >= shuffled.length) return;

        const book = shuffled[bookIndex];
        bookIndex++;

        try {
          const res = await fetch(`https://www.googleapis.com/books/v1/volumes?q=intitle:${encodeURIComponent(book.title)}+inauthor:${encodeURIComponent(book.author)}&maxResults=1`);
          const data = await res.json();

          if (data.items && data.items[0]) {
            const volumeInfo = data.items[0].volumeInfo;
            if (volumeInfo.imageLinks) {
              const link = document.createElement('a');
              link.style.display = 'none';
              link.style.lineHeight = '0';
              link.target = '_blank';
              if (volumeInfo.infoLink) {
                link.href = volumeInfo.infoLink;
              }

              const img = document.createElement('img');
              img.style.cssText = 'height: 140px; border: 1px dotted #666; background: transparent;';
              img.src = volumeInfo.imageLinks.thumbnail;
              img.onload = () => {
                link.style.display = 'inline-block';
              };

              link.appendChild(img);
              container.appendChild(link);
              displayedBooks++;
              
              if (displayedBooks < 2) {
                tryNextBook();
              }
            } else {
              console.log(`Cannot find book cover for: ${book.title} by ${book.author}`);
              tryNextBook();
            }
          } else {
            console.log(`Cannot find book: ${book.title} by ${book.author}`);
            tryNextBook();
          }
        } catch (err) {
          console.log(`Error fetching book: ${book.title} by ${book.author}`, err);
          tryNextBook();
        }
      }

      tryNextBook();
    } else {
      document.querySelector('.book-covers').style.display = 'none';
    }
  </script>

  </div>



<p> I seek refuge in God, from Satan the rejected. Generated by: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 30.2 (<a href="https://orgmode.org">Org</a> mode 9.7.34). Written by: Salih Muhammed, by the date of: 2023-02-16 Thu 18:55. Last build date: 2025-11-28 Fri 15:59.</p>




</div>
</div>
</body>
</html>
